<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++2.0]]></title>
    <url>%2Funcategorized%2FCpp11%2F</url>
    <content type="text"><![CDATA[auto auto不能用来声明函数的返回值。但是如果函数有一个尾随的返回类型，auto是可以声明返回值。1234template&lt;class T1, class T2&gt;auto test(T1 t1,T2 t2) -&gt; **decltype**(t1 + t2)&#123; return t1+t2;&#125; std::array array对象的长度是固定的，使用了静态存储区，即存储在栈上，效率跟数组相同，但是更加的安全。 nullptr nullptr-&gt;void* nullptr是std::nullptr_t。存在和任何指针类型以及类成员指针类型的空值，bool类型的隐式转换。 不存在整型的隐式转换。12345678910f(int *p)&#123;&#125;f1(bool o)&#123;&#125;f2(std::share_ptr&lt;int&gt; p)&#123;&#125; int p1 = NULL;int p2 = nullptr;if(p1==p2);f(p2);f1(p2);f2(p2);int i = nullptr; //false 基于范围的for循环12345678910111213for ( val declare : collection ) statementfor(int e : arr)&#123; e = e*e; std::cout&lt;&lt;e&lt;&lt;std::endl;&#125;template&lt;class InputIterator, class Function&gt; Function for_each( InputIterator _First, InputIterator _Last, Function _Func ); override final override:表示函数应当重写基类中的虚函数。 final:表示派生类不应当重写这个虚函数。12345678910111213141516171819class A&#123; public: virtual void func(int i)&#123; cout&lt;&lt;"A::f"&lt;&lt;endl; &#125;&#125;;class B : public A&#123; public: virtual void func(long l) final &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;;class C : public A&#123; public: virtual void func(int i) override &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;; 强类型枚举 传统enum会将常量暴露在外层作用域。存在隐式整型转型。 强类型枚举由关键字enum class标识，不存在隐式转整型。12enum class a&#123;one,two,all&#125;;a ob = a::one; variadic templates 可变参数列表, 类型和个数任意1234567891011template &lt;class T, class... Args&gt;void print(const T &amp;first, const Args &amp;... args)&#123; cout&lt;&lt;first&lt;&lt;endl; print(args...);&#125;void print()&#123;&#125;template&lt; class...T&gt;void print(const Args &amp;... args)&#123; /**/&#125; 智能指针 pointer-like classess#include&lt;memoray&gt; 智能指针构造函数是explicit,拒绝隐式转换。 123456shared_ptr&lt;double&gt;pd;double *p_reg = new double;pd = p_reg;//错误，不允许隐式转换pd = shared_ptr&lt;double&gt;(p_reg);//正确shared_ptr&lt;double&gt;pshared = p_reg;//错误，不允许隐式转换shared_ptr&lt;double&gt;pshared(p_reg);//正确 不能将smart point 应用非堆内存. aoto_ptrp(new T);auto_ptrp(new T);unique_ptrp(new T);##shared_ptrp(new T); 12345678910template &lt; class T&gt;class shared_ptr&#123; private: T *p; public: shared_ptr(T *pm):p(pm)&#123;&#125; T&amp; operator*() const&#123;return *p;&#125; T* operator-&gt;() const&#123;return p;&#125;&#125;;//-&gt;运算符作用之后得到的输出继续用-&gt;作用。 迭代器 pointer-like classes12345678910111213141516171819template&lt; class T&gt;struct __list_node&#123; void *prev; void *next; T data;&#125;;template&lt; class T,class Ref, class Ptr&gt;class __list_iterator&#123; typedef __list_iterator&lt;T,Ref,Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; link_type node; bool operator==(const self&amp;x)const&#123; return node == x.node; &#125; reference operator*() const &#123;return (*node).data;&#125; pointer operator-&gt;() const &#123;return &amp;(operator*());&#125;&#125; std::bind 将函数、成员函数和闭包转成function函数对象 将多元(n&gt;1)函数转成一元函数或者(n-1)元函数。 123456789101112template&lt; class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );template&lt; class R, class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args ); auto x1 = bind(f,10,20,10); auto x2 = bind(f,std::placeholders::_1,2,3); auto x3 = bind(f,std::placeholders::_1,23,std::placeholders::_2); auto x4 = bind&lt;double&gt;(f,std::placeholders::_1,std::placeholders::_2,5); cout&lt;&lt;x1()&lt;&lt;endl; cout&lt;&lt;x2(1)&lt;&lt;endl; cout&lt;&lt;x3(20,32)&lt;&lt;endl; cout&lt;&lt;x4(23,12)&lt;&lt;endl; 某些无法拷贝的参数，只能使用引用传递，需要使用ref 1for_each(words.begin(),words.end,bind(print,ref(os),_1,' ')); bind 无法绑定重载函数,因为重载函数参数个数不同。 bind 绑定成员函数，需要类的实例作为第二个参数。 bind 绑定成员函数，不需要类实例。 123A a();auto m = bind(&amp;A::f(),a);m(); 未完待续]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>c++</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存管理侯捷]]></title>
    <url>%2Funcategorized%2Fmemory_control%2F</url>
    <content type="text"><![CDATA[内存分配方式 栈 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆 手动delete，程序结束后，OS自动回收。堆是一块连续的内存区域。这块内存区域的起始位置和结束位置，并且这块连续的内存区域可以被程序员随意使用，并且这块区域是很大。 自由变量区 由malloc 全局/静态存储区 常量存储区 primitivesmalloc/freestd::allocatorother allocatorloki::allocator]]></content>
      <tags>
        <tag>c++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据结构整理]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fdatastructure%2F</url>
    <content type="text"><![CDATA[顺序结构顺序栈12345678910111213template &lt;class T&gt;class sq_stack&#123;private: T val; int top; int size;public: sq_stack(); ~sq_stack(); T pop(); void insert(T val); int get_size(sq_stack s);&#125; 队列1234567891011121314template&lt;class T&gt;class sq_queue&#123;private: T val; int front; int rear; int maxsize;public: sq_queue(); ~sq_queue(); int get_rear(sq_queue r); int get_front(sq_queue f); void insert(T val);&#125; 顺序表123456template &lt;class T&gt;class sq_list&#123; vector&lt;T&gt; a; int length; int size;&#125; 链式结构## 12345678910111213template &lt;class T&gt;class link_node&#123;private: T data; link_node *next;public: link_node(T d):data(d),next(nullptr)&#123;&#125; ~link_node();&#125;typedef struct Lnode&#123; elemtype data; struct Lnode *next;&#125;Lnode,*LinkList; 哈希表 哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突解决方法链地址法：key相同用单链表链接开放定址法： 线性探测法：放到key的下一个位置，Hi = (H(key) + i) % m 二次探测法：Hi = (H(key) + i) % m 随机探测法：Hi= (H(key) + 伪随机数) % m 123456789101112typedef char KeyType;typedef struct&#123; KeyType key;&#125;RcdType;typedef struct&#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 🌲二叉🌲存储结构 顺序存储 链式存储遍历方式 先序 后序 中序 层次实现1234567891011121314template &lt;class T&gt;class binary_node&#123;private: binary_node *left; binary_node *right; T val;public: binary_node(int x):val(x),left(nullptr),right(nullptr)&#123;&#125; ~binary_node(); void in_order(binary_node *root); void pre_order(binary_node *root); void post_order(binary_node *root); void level_order(binary_node *root);&#125; 类型 满二叉🌲 完全二叉🌲(堆) 大根堆 小根堆 二叉查找🌲(排序🌲) 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找的最大次数等于数的高度。缺点(多次插入偏向一边的数据，会导致🌲严重不平衡) 平衡二叉🌲(AVL) 最小失衡🌲(平衡二叉树插入新的节点导致失衡的子🌲):调整策略 LL 左孩子右旋 RR 右孩子左旋 LR 左孩子左旋，再右旋 RL 右孩子的左子🌲先右旋，在左旋红黑🌲解决了二叉查找树的不平衡问题。最大查找次数不会超过最短路径的两倍。 节点是红色或黑色。 根节点为黑色。 所有的叶子节点都是黑色的空节点。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。自平衡 变色 旋转 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum tree_color(RED,BLACK);template &lt;class T&gt;class rb_node&#123;public: tree_color color; T key; rb_node *left; rb_node *right; rb_node *parent; rb_node(T val,rb_color c,rb_node l,rb_node r,rb_node p):key(val),color(c),left(l),right(r),parent(p)&#123;&#125;&#125;;template &lt;class T&gt;class rb_tree&#123; rb_tree(); ~rb_tree(); void pre_order(); void in_order(); void post_order(); rb_node&lt;T&gt;* re_search(T key); //递归查找 rb_node&lt;T&gt;* iter_serach(T key); //非递归 T minkey(); T maxkey(); rb_node&lt;T&gt;* successor(rb_node&lt;T&gt; *x); rb_node&lt;T&gt;* predecessor(rb_node&lt;T&gt; *x); void insert(T key); void remove(T key); void destory(); void print();private: void left_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x); void right_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x);&#125;## B🌲* m阶B🌲 1. 每个结点最多有m-1个关键字 2. 根结点最少可以只有1个关键字 3. 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它 4. 根结点到每个叶子结点高度相同 5. 非根结点至少有Math.ceil(m/2)-1个关键字### 实现```c++template &lt;class T&gt;struct B_tree_node &#123; int n; T *key; bool is_leaf; struct B_tree_node *parent; struct B_tree_node **child;&#125;;template &lt;class T&gt;class B_tree&#123;private: B_tree_node&lt;T&gt;* root; int m;public: B_tree(int tVal = 2); ~B_tree(); B_tree_node&lt;T&gt;* search_tree(B_tree_node&lt;T&gt;* root, T k ,int &amp;index); B_tree_node&lt;T&gt;* getRoot(); void insert(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); void delete(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); T get_value(B_tree_node&lt;T&gt;* root,T value);&#125;; B+ M阶B+🌲 内结点存有关键字和指向孩子结点指针。外结点存有关键字和数据。 叶子结点还有关键字，按照关键字大小排序，叶子结点中存在指向兄弟结点的指针。 一颗B+🌲存在两个指针，一个指向根结点，一个指向存有最小关键字的结点。 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引。 123456789101112template &lt;class T&gt;class bp_node&#123; public: bp_node(); virtual ~bp_node(); private: T data;&#125;;template &lt;class T&gt;class inter_node: public bp_node&#123; public:&#125; 八叉树图排序查找递归折半查找归并查找快速排序迭代折半查找归并查找]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>B树</tag>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础总结2]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_two%2F</url>
    <content type="text"><![CDATA[OOP 多态 C++多态分类及其实现 重载多态(Ad-hoc Polymorphism,编译期) 函数重载，运算符重载 子类型多态(Subtype Polymorphism,运行期) 虚函数 参数多态性(Parametric PolyMorphism) 编译期 类模板，函数模板 强制多态(Coerion PolyMorphism 编译期,运行期) 类型转换 静态多态（编译期间，早绑定） 函数重载 动态多态（运行期间，晚绑定） 虚函数 tips: 普通函数不可是virtual static 不可为virtual 构造函数不可为virtual,因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针 virtual ~作用 * 解决based point-&gt; derived object,用based point 删除derived object.虚函数指针，虚函数表虚继承虚继承用于解决多继承条件下的菱形继承问题浪(费存储空间、存在二义性) * 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4字节）和虚基类表(不占用类对象的存储空间)(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了);当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 * 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。虚函数和虚继承 都使用了虚指针(占用类的存储空间)和虚表（不占类存储空间） 虚函数表存储的是虚函数地址，虚基类表存储相对直接继承类的位偏移。 虚基类在子类中存在一份拷贝，而虚函数不占用存储空间。 tips: 模板类可以使用虚函数。 但任何类的成员模板函数不能是虚函数。 聚合类用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配管理 malloc 申请指定字节内存，初始值不确定。 char *str = (char*) malloc(100); calloc 为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc 更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca 在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 new/new[]先底层调用malloc，然后调用构造函数。 delete/delete[]先调用析构函数，然后free，指针置为空。 new能自动计算所需字节数，无需像malloc一样手动操作。 pacement new允许传递额外的地址参数，预先在指定的内存区域创建对象。 123456new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list&#125;//place_address 为 point//initializers可能为空的初始化列表 tips: delete this 合法前提 之后不再调用this指针(任何调用) this对象由new而不是其他任何方式分配的。 该成员函数是this对象最后调用的的成员函数。 剩下的成员函数（delete this之后的)不接触到this对象,包括调用任何其他成员函数或访问任何数据成员。 只在堆上生成对象的类方法：将虚构函数私有。 (C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。) 只在栈上生成对象的类方法：将new和delete操作符重载为私有。 ：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础总结1]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_one%2F</url>
    <content type="text"><![CDATA[const(不可变)作用1. 修饰常量 2. 修饰指针 指针常量和常量指针 3. 常量引用 避免拷贝，避免对值的修改，不能使用非const引用指向const对象。 4. 修饰成员函数 函数内部不能修改成员函数使用123456789101112131415161718192021const int a1;int get() const;const char* p1 = a2;//常量指针，指向常量的指针，保护指向的地址空间数据不可变。指针可变，可以修改const指针所指向的值的，但是不能通过const对象指针来进行，自以为指向const的指针。char* p = a2;*p = a3;char* const p2 = a3;//指针常量， 保护指针，指针自身的地址空间不可变，数据可变。//不能把常量的地址赋给指针变量void get(const int val);void get(const int *val);void get(int *const val);//file1.cppint cout;const int cout2;extern const int cout3;//file2.cppextern int cout; //在全局作用域里定义非const变量时，它在整个程序中都可以访问cout++;cout2; //error除非特别说明，在全局作用域声明的const变量是定义该对象的文件的局部变量，只存在于那个文件，不能被其他文件访问。extern const int cout3;cout3++; static()作用1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前分配空间，如果有初始值就用初始值初始化，如果没有初始值系统用默认值初始化。 2. 修饰普通函数，该函数仅在定义该函数的文件内才能使用。 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，使用类名作用域符号访问，但是在 static 函数内不能访问非静态成员。this指针1. 指向非静态成员的特殊指针。 2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 3. this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值。在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。 4. this 只是一个右值，不能使用&amp;this 5. 在以下场景中，经常需要显式引用 this 指针： 1. 为实现对象的链式引用。 2. 为避免对同一对象进行赋值操作。 3. 在实现一些数据结构时，如 list。inline特征1. 相当于直接执行函数体。 2. 相当于宏操作，但是多了类型检查。 3. 编译器一般不内敛包含循环，递归，switch等复杂操作的inline函数。 4. 在类声明中定义的函数，除了虚函数的其他函数会自动隐式地当成inline函数。使用12345// 类外定义需要显示inlineclass A&#123; void b();&#125;inline void A::b()&#123;&#125;; 编译器对inline函数的处理过程1. 函数体复制到调用点。 2. 为局部变量分配内存空间。 3. 将inline函数中的输入参数和返回值映射到调用方法的局部变量空间。 4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。优劣优点1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 4. 内联函数在运行时可调试，而宏定义不可以。缺点1. 代码膨胀，省去了调用函数的开销。关键在于函数体内执行时间和调用函数开销的平衡。 2. inline函数无法随着函数库升级而升级，inline函数改变需要重新编译，无法直接链接。 3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。tips: virtual可以inline，但是当virtual表示多态性时，不能内联。 inline是编译器建议编译器内联，在程序运行之前，但是多态性的表现在程序运行中。 当编译器明确知道调用对象是哪一个类时，具有实际对象，而不是对象指针或引用，可以使用 inline virtual volatile1volatile int a = 1; 1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 2. volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） 3. const 可以是 volatile （如只读的状态寄存器） 4. 指针可以是 volatile12345678## assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。### 使用```c++# define NDEBUG# cinlude &lt;cassert&gt;assert(p!=NULL); pragma pack(n)强制设定struct,union,class成员变量以n 字节对齐方式。 12#pragma pack(push)#pragma pack(8) 位域1Bit mode:2; 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。 位域内存布局和机器有关 类型必须是整型或者枚举，signed int根据具体实现而定。 取地址和指针不能作用于位域。 extern “C”按照C语言方式编译和链接。extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 1234567#ifdef _cpextern "C"&#123;#endif void *memeset(void *,int ,size_t);#ifdef _cp&#125;#endif structc12345typedef struct a&#123;&#125;s;// 等价于struct a&#123;&#125;;typedef struct a s;// 但两个标识符名称空间不相同。 cpp编译器定位符号的规则改变，首先搜索全局标识符表，如果没有将会搜索类标识符表。 没有同名类 A，可省略struct 12struct A&#123;&#125;;void m(A m); 如果有同名类 A，则A 代表类A，struct A 代表结构体A。 class和struct 本质区别是默认的访问权限，struct默认public,class默认private。 union联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： * 默认权限public * 可以含有析构函数，构造函数 * 不能含有引用类型的成员 * 不能作为derived class，不能作为base class * 不能含有virtual * 匿名union在定义所在的scope可直接访问union member * 匿名union不能包含protected和private member * 全局匿名联合必须是static。explicit 修饰构造函数，防止隐式转换和复制初始化。 修饰转换函数，防止隐式转换，按语境转换除外。 按语境转换 if、while、for 的控制表达式； 内建逻辑运算符 !、&amp;&amp; 和 || 的操作数； 条件运算符 ?: 的首个操作数； static_assert 声明中的谓词； noexcept 说明符中的表达式；12345678910111213141516171819202122232425262728293031class A&#123; A(int a)&#123;&#125; operator bool() const &#123;return false;&#125;&#125;;class B&#123; B(int b)&#123;&#125; explicit operator bool() const&#123;return false;&#125;&#125;;void getA(A a)&#123;&#125;void getB(B b)&#123;&#125;int main()&#123; A a1(1);//直接初始化 A a2 = 1;//复制初始化 A a3&#123;1&#125;;//直接列表初始化 A a4 = &#123;1&#125;;//复制列表初始化 A a5 = (A)1;//允许static_cast 显示转型 getA(1);//允许int到A的隐式转换 if (a1);//使用转换函数A::operator bool() 的从A到bool的隐式转换 bool a6(a1);//使用转换函数 A::operator bool()的从A到bool的隐式转换 bool a7 = a1;//使用转换函数A::operator bool()的从A到bool的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1);//static_cast 进行直接初始化 B b1(1);//ok B b2 = 1;//false, explitct修饰的构造函数不可复制初始化，不可复制列表初始化 getB(b1);// 被explicit修饰的构造函数的对象不允许你int到B隐式转换 if(b1); bool b6(b1); //被explicit 修饰的转换函数的对象可以按语境转换。 bool b7 = b1; false，被explicit修饰的构造函数的对象不允许B到bool的转型。 bool b8 = static_cast&lt;bool&gt;(b1); return 0;&#125; 引用1) 左值引用声明符：声明 S&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的左值引用。 2) 右值引用声明符：声明 S&amp;&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的右值引用。 * 不存在 void 的引用，也不存在引用的引用,引用的数组,指向引用的指针. * 引用坍缩：容许通过模板或 typedef 中的类型操作构成引用的引用，这种情况下适用引用坍缩（reference coolapsing）规则：右值引用的右值引用 坍缩成右值引用，所有其他组合均 坍缩成左值引用; * 当函数的返回值是左值引用时，函数调用表达式成为左值表达式：1234567typedef int&amp; lref;typedef int&amp;&amp; rref;int n;lref&amp; r1 = n; // r1 的类型是 int&amp;lref&amp;&amp; r2 = n; // r2 的类型是 int&amp;rref&amp; r3 = n; // r3 的类型是 int&amp;rref&amp;&amp; r4 = 1; // r4 的类型是 int&amp;&amp; 左值引用常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 右值引用可用于为临时对象延长生存期（左值引用亦能延长临时对象生存期，但不能通过左值引用修改）成员初始化列表有些场合必须要用初始化列表： 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++多线程]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Fthread%2F</url>
    <content type="text"><![CDATA[多进程并发将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。独立的进程可以通过进程间常规的通信渠道传递讯息。 + 缺点 因为OS的保护措施，进程之间的通信通常复杂或者慢。 运行多个进程需要时间启动进程，操作系统需要内部资源来管理进程。 + 优点 OS 在进程间提供附加的保护操作和高级别的通信机制，使得更容易编写安全的并发代码。 可以使用远程连接的方式，在不同的机器上运行独立的进程。多线程并发并发的另一个途径是在单个进程中运行多个线程。线程类似于轻量级的进程。 + 缺点 缺少线程间的数据保护，如果数据要被多个线程访问，我们必须确保每个线程所访问的的数据是一致的，因此需要对线程通信做大量的工作。 + 优点 共享地址空间，缺少数据保护，所以工作量小，多线程开销远小于多进程。C++ 11 std::thread+ C++ 11 引入了&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。+ 声明了 std::atomic和 std::atomic_flag + 生命了一套C风格的原子类型及兼容C的操作函数。+ 声明了 std::thread,std::this_thread+ 声明了相关mutex类。 + std::mutex,std::lock_guard,std::unique_lock.+ 相关condition_variable 类， std::condition_variable和std::condition_variable_any+ std::promise,std::package_task.std 线程类+ std::thread 类的构造函数使用可变参数模板。 1template&lt;typename _Callable, typename... _Args&gt; 1. 函数指针 2. 重载运算符的类对象,仿函数 3. lambda表达式 4. std::function函数指针1234567891011void func1()&#123;&#125;void func2(int i)&#123;&#125;void func3(int i,std::string m)&#123;&#125;std::thread t1(func1);std::thread t2(func2,1);std::thread t3(func3,1,"abc");t1.join();t2.join();t3.join(); 仿函数123456789101112class Fctor &#123;public: // 具有一个参数 void operator() () &#123; &#125;&#125;;Fctor f;std::thread t1(f); std::thread t2(Fctor()); // falsestd::thread t3((Fctor())); // okstd::thread t4&#123;Fctor()&#125;; // ok 一个仿函数类生成的对象，使用起来就像一个函数一样. t2错误，编译器把Fctor()解释为函数声明，并非是临时对象。 在参数添加小括号，进行调用。 使用{}进行构造。 lambda 函数123456std::thread t1([]()&#123; std::cout&lt;&lt;"lambda"&lt;&lt;std::endl;&#125;);//无参std::thread t2([](std::int m)&#123; std::cout&lt;&lt;"lambda"&lt;&lt;m&lt;&lt;std::endl;&#125;,1);//有参 std::fucntion1234567891011121314151617181920212223class A&#123;public: void func1()&#123; &#125; void func2(int i)&#123; &#125; void func3(int i, int j)&#123; &#125;&#125;;A a;std::function&lt;void(void)&gt; f1 = std::bind(&amp;A::func1, &amp;a);std::function&lt;void(void)&gt; f2 = std::bind(&amp;A::func2, &amp;a, 1);std::function&lt;void(int)&gt; f3 = std::bind(&amp;A::func2, &amp;a, std::placeholders::_1);std::function&lt;void(int)&gt; f4 = std::bind(&amp;A::func3, &amp;a, 1, std::placeholders::_1);std::function&lt;void(int, int)&gt; f5 = std::bind(&amp;A::func3, &amp;a, std::placeholders::_1, std::placeholders::_2);std::thread t1(f1);std::thread t2(f2);std::thread t3(f3, 1);std::thread t4(f4, 1);std::thread t5(f5, 1, 2); 构造函数的第一个参数是可调用对象，默认情况下传递的是一个副本。当使用构造函数创建对象的时候，是将参数先赋值给这些变量，所以这些变量只是个副本，然后在线程启动并调用线程入口函数时，传递的参数只是这些副本。 线程对象只能移动不可复制将线程的所有权在std::thread实例间进行转移。1234void f1();void f2();std::thread t1(f1);std::thread t2 = std::move(t1); 使用ref()和move()传递引用,thread t(f,ref(m));]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>未完待续</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常类]]></title>
    <url>%2Funcategorized%2Fexception%2F</url>
    <content type="text"><![CDATA[中定义了一系列标准的异常。 std::exceptionstd::bad_alloc 该异常可以通过 new 抛出。std::bad_cast 该异常通过dynamic_cast抛出。std::bad_exception std::bad_typeid 该异常可以通过 typeid 抛出。std::logic_error 理论上可以通过读取代码来检测到的异常。std::domain_error 当使用了一个无效的数学域时，会抛出该异常。std::invalid_argument 当使用了无效的参数时，会抛出该异常。std::length_error 当创建了太长的 std::string 时，会抛出该异常。std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。std::runtime_error 理论上不可以通过读取代码来检测到的异常。std::overflow_error 当发生数学上溢时，会抛出该异常。std::range_error 当尝试存储超出范围的值时，会抛出该异常。std::underflow_error 当发生数学下溢时，会抛出该异常。]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memo]]></title>
    <url>%2Funcategorized%2Fmemo%2F</url>
    <content type="text"><![CDATA[方法一：暴力法123456789int climb(int i,int n)&#123;if(i&gt;n) return 0;if(i ==n) return 1;return climb(i+1,n)+climb(i+2,n);&#125;int climbs(int n)&#123; return climb(0,n);&#125; 时间复杂度：O(2n)O(2^n)O(2n)。树形递归的大小为 2n2^n2n . 空间复杂度：O(n)。递归树的深度可以达到 nn 方法 2：记忆化递归12345678910111213class Solution&#123; public: climbs(int n)&#123; vector&lt;int&gt; memo; return climbs(0,n,memo); &#125; int climb_memo(int i,int n,vector&lt;int&gt; memo)&#123; if(i&gt;n) return 0; if(i ==n) return 1; if(memo[i]&gt;0) return memo[i]; return climb_memo(i+1,n,memo)+climb_memo(i+2,n,memo); &#125;&#125; 时间复杂度：O(n) 。树形递归的大小可以达到 n. 空间复杂度：O(n) 。递归树的深度可以达到 n. 方法 3：动态规划12345678910111213class Solution&#123; public: climbs(int n)&#123; if(n==1) return 1; &#125; vector&lt;int&gt; dp; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++)&#123; dp[i] = dp[i-1] + dp[i-2] &#125; return dp[n];&#125; 时间复杂度：O(n)，单循环到 n 。 空间复杂度：O(n), dp 数组用了 n 的空间]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 导入conda环境]]></title>
    <url>%2Funcategorized%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebook导入conda环境 不使用ipykernel，采用nb_condaconda install nb_conda 注意安装的时候不要激活环境 可以直接在jupyter里面安装包 可以在ipynb里面更改环境]]></content>
      <tags>
        <tag>conda</tag>
        <tag>jupyter</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
</search>
