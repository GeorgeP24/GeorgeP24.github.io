<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pytorch]]></title>
    <url>%2F2019%2F07%2F02%2Fpytorch%2F</url>
    <content type="text"><![CDATA[torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor) 沿给定dim维度返回输入张量input中 k 个最大值。 如果不指定dim，则默认为input的最后一维。 如果为largest为 False ，则返回最小的 k 个 值。 返回一个元组 (values,indices)，其中indices是原始输入张量input中测元素下标。如果设定布尔值sorted 为_True_，将会确保返回的k 个值被排序。 input (Tensor) – 输入张量 k (int) – “top-k”中的k dim(int, optional) – 排序的维 largest(bool, optional) – 布尔值，控制返回最大或最小值 sorted(bool, optional) – 布尔值，控制返回值是否排序 out(tuple, optional)–可选输出张量 (Tensor, LongTensor) output buffer torch.sort(input, dim=None, descending=False, out=None)-&gt;(Tensor, LongTensor) 对输入张量 input 沿着指定维按升序排序。如果不给定 dim ，则默认为输入的最后一维。如果指定参数 descending 为 True ，则按降序排序 返回tuple(sorted_tensor, sorted_indices) 会改变tensor的函数操作会用一个下划线后缀来标示。比如,torch.FloatTensor.abs_()会在原地计算绝对值，并返回改变后的tensor，而tensor.FloatTensor.abs()将会在一个新的tensor中计算结果。 view()函数作用是将一个多行的Tensor,拼接成一行。 torch.max(x,1 or 0) 返回两个res，第一个是最大值，第二个是对应的索引值；第二个参数 0 代表按列取最大值并返回对应的行索引值，1 代表按行取最大值并返回对应的列索引值。 transpose只能操作2D矩阵的转置。有两种调用方式。连续使用transpose也可实现permute的效果。 torch.index_select(input, dim, index, out=None)-&gt;Tensor w 在指定维度dim方向上从input中抽取由位置序列index所指定的值。output的其他维度的长度和原来矩阵相同，在第dim维度上的长度和index的长度相同。 torch 加法 第一种：a+b 第二种：torch.add(a,b) 第三种：result = torch.Tensor(5,3)torch.add(a,b,out=result) #把运算结果存储在result上 第四种：b.add_(a) #把运算结果覆盖掉b 乘积 Pytorch 的 mm 是矩阵的外积，而dot是元素对应积，即对应位置的元素相乘，需要左右矩阵形状一致。这点和numpy、mxnet不一样。 torch.div(input,value,out=None) -&gt; Tensor #逐元素除 expand(*sizes) -&gt; Tensor expand_as(tensor) == self.expand(tensor.size()) torch.unsqueeze(input, dim=None, out=None) 返回一个新的张量，对输入的制定位置插入维度 1 注意:返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。 将输入张量形状中的1 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)，那么输出形状就为:(A×B×C×D)当给定dim时，那么挤压操作只在给定维度上。例如，输入形状为: (A×1×B), squeeze(input, 0) 将会保持张量不变，只有用 squeeze(input, 1)，形状会变成 (A×B)。 如果dim为负，则将会被转化dim+input.dim()+1 tensor (Tensor) – 输入张量 dim (int) – 插入维度的索引 out (Tensor, optional) – 结果张量]]></content>
  </entry>
  <entry>
    <title><![CDATA[闲杂笔记]]></title>
    <url>%2F2019%2F06%2F08%2Fcppnote%2F</url>
    <content type="text"><![CDATA[Cin.get(),返回一个cin对象，会把换行符留在输入队列，若连续输入，可以：使用cin.get()或者cin.get().get(). Delete [] p; 删除整个动态数组。 大多数情况，把数组名解析成地址。但是在sizeof运算中，并不会这样。sizeof运算在数组上，得到的是数组的长度。 auto关键字只能用于单值初始化推断，不能用于初始化列表。 数据成员被初始化的顺序和他们在类声明中的顺序相同，与初始化器中的顺序无关。 赋值符号进行浅拷贝，指向同一地址，不开辟新的内存空间。深拷贝开辟新的内存空间。 new A和new A() 区别 ,当A是POD时，有区别，且C++98和C++03会有区别。在Apple LLVM version 9.0.0 (clang-900.0.38)没有区别。 POD是Plain old data的缩写，它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。 算数表达式中，同时存在unsigned和int，会把int转化为unsigned。无符号数运算结果如何是有符号数会自动转型无符号。 字符型分为，char， signed char，unsigned char. unsigned和signed混合计算，结果不要出现负数。 C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量. ::全局作用符覆盖默认作用域规则。 void *p 可以指向所有类型，但是不能操作内容。 对于string类的输入函数，它会自动忽略开头的空白（空格、制表符、换行等等），从第一个真正的字符开始直到下一个空白。 对于getline()函数，它会保存字符串中的空白符，它读入数据，直到遇到换行符位置。 size_t类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。是unsigned int。 栈解旋:从进入try块到抛出异常之前，栈中构造的所有对象将被析构，析构顺序和构造顺序相反。 栈上：A a();//这里声明了一个函数，没有传入的参数，返回值为类类型A b;//默认调用“对象名()”这个构造函数构造对象A c(1);//默认调用相应的构造函数构造对象堆上:加括号不加括号一般无差别，都调用默认的构造函数(参考条例7)A *d = new A();A *e = new A;对于内置类型而言:加括号是进行了初始化，不加是未进行初始化int *f = new int();int *g = new int; 未完待续 闲杂笔记]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
</search>
