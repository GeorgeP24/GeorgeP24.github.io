<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基本数据结构整理]]></title>
    <url>%2F2019%2F07%2F30%2Fdatastructure%2F</url>
    <content type="text"><![CDATA[顺序结构顺序栈12345678910111213template &lt;class T&gt;class sq_stack&#123;private: T val; int top; int size;public: sq_stack(); ~sq_stack(); T pop(); void insert(T val); int get_size(sq_stack s);&#125; 队列1234567891011121314template&lt;class T&gt;class sq_queue&#123;private: T val; int front; int rear; int maxsize;public: sq_queue(); ~sq_queue(); int get_rear(sq_queue r); int get_front(sq_queue f); void insert(T val);&#125; 顺序表123456template &lt;class T&gt;class sq_list&#123; vector&lt;T&gt; a; int length; int size;&#125; 链式结构## 12345678910111213template &lt;class T&gt;class link_node&#123;private: T data; link_node *next;public: link_node(T d):data(d),next(nullptr)&#123;&#125; ~link_node();&#125;typedef struct Lnode&#123; elemtype data; struct Lnode *next;&#125;Lnode,*LinkList; 哈希表 哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突解决方法 链地址法：key相同用单链表链接 开放定址法： * 线性探测法：放到key的下一个位置，Hi = (H(key) + i) % m * 二次探测法：Hi = (H(key) + i) % m * 随机探测法：Hi= (H(key) + 伪随机数) % m 123456789101112typedef char KeyType;typedef struct&#123; KeyType key;&#125;RcdType;typedef struct&#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 🌲二叉🌲存储结构1. 顺序存储 2. 链式存储遍历方式1. 先序 2. 后序 3. 中序 4. 层次类型 满二叉🌲 完全二叉🌲(堆) 大根堆 小根堆 二叉查找🌲(排序🌲) 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找的最大次数等于数的高度。缺点(多次插入偏向一边的数据，会导致🌲严重不平衡) 平衡二叉🌲(AVL) 最小失衡🌲(平衡二叉树插入新的节点导致失衡的子🌲):调整策略 LL 左孩子右旋 RR 右孩子左旋 LR 左孩子左旋，再右旋 RL 右孩子的左子🌲先右旋，在左旋红黑🌲解决了二叉查找树的不平衡问题。最大查找次数不会超过最短路径的两倍。 节点是红色或黑色。 根节点为黑色。 所有的叶子节点都是黑色的空节点。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。自平衡 变色 旋转 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。 实现enum tree_color(RED,BLACK); template &lt;class T&gt; class rb_node{ public: tree_color color; T key; rb_node *left; rb_node *right; rb_node *parent; rb_node(T val,rb_color c,rb_node l,rb_node r,rb_node p):key(val),color(c),left(l),right(r),parent(p){} }; template &lt;class T&gt; class rb_tree{ rb_tree(); ~rb_tree(); void pre_order(); void in_order(); void post_order(); rb_node&lt;T&gt;* re_search(T key); //递归查找 rb_node&lt;T&gt;* iter_serach(T key); //非递归 T minkey(); T maxkey(); rb_node&lt;T&gt;* successor(rb_node&lt;T&gt; *x); rb_node&lt;T&gt;* predecessor(rb_node&lt;T&gt; *x); void insert(T key); void remove(T key); void destory(); void print(); private: void left_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x); void right_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x); } B🌲B+八叉树图排序查找递归折半查找归并查找快速排序迭代折半查找归并查找]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础总结]]></title>
    <url>%2F2019%2F07%2F30%2Finterview_two%2F</url>
    <content type="text"><![CDATA[OOP 多态 C++多态分类及其实现 重载多态(Ad-hoc Polymorphism,编译期) 函数重载，运算符重载 子类型多态(Subtype Polymorphism,运行期) 虚函数 参数多态性(Parametric PolyMorphism) 编译期 类模板，函数模板 强制多态(Coerion PolyMorphism 编译期,运行期) 类型转换 静态多态（编译期间，早绑定） 函数重载 动态多态（运行期间，晚绑定） 虚函数 tips: 普通函数不可是virtual static 不可为virtual 构造函数不可为virtual,因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针 virtual ~作用 * 解决based point-&gt; derived object,用based point 删除derived object.虚函数指针，虚函数表虚继承虚继承用于解决多继承条件下的菱形继承问题浪(费存储空间、存在二义性) * 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4字节）和虚基类表(不占用类对象的存储空间)(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了);当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 * 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。虚函数和虚继承 都使用了虚指针(占用类的存储空间)和虚表（不占类存储空间） 虚函数表存储的是虚函数地址，虚基类表存储相对直接继承类的位偏移。 虚基类在子类中存在一份拷贝，而虚函数不占用存储空间。 tips: 模板类可以使用虚函数。 但任何类的成员模板函数不能是虚函数。 聚合类用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配管理 malloc 申请指定字节内存，初始值不确定。 char *str = (char*) malloc(100); calloc 为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc 更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca 在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 new/new[]先底层调用malloc，然后调用构造函数。 delete/delete[]先调用析构函数，然后free，指针置为空。 new能自动计算所需字节数，无需像malloc一样手动操作。 pacement new允许传递额外的地址参数，预先在指定的内存区域创建对象。 123456new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list&#125;//place_address 为 point//initializers可能为空的初始化列表 tips: delete this 合法前提 之后不再调用this指针(任何调用) this对象由new而不是其他任何方式分配的。 该成员函数是this对象最后调用的的成员函数。 剩下的成员函数（delete this之后的)不接触到this对象,包括调用任何其他成员函数或访问任何数据成员。 只在堆上生成对象的类方法：将虚构函数私有。 (C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。) 只在栈上生成对象的类方法：将new和delete操作符重载为私有。 ：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础总结]]></title>
    <url>%2F2019%2F07%2F29%2Finterview_one%2F</url>
    <content type="text"><![CDATA[const(不可变)作用1. 修饰常量 2. 修饰指针 指针常量和常量指针 3. 常量引用 避免拷贝，避免对值的修改 4. 修饰成员函数 函数内部不能修改成员函数使用12345678const int a1;int get() const;const char* p1 = a2;//常量指针，指向常量的指针，保护指向的地址空间不可变。指针可变。char* const p2 = a3;//指针常量， 保护指针，指针自身的地址空间不可变，数据可变。//不能把常量的地址赋给指针变量void get(const int val);void get(const int *val);void get(int *const val); static()作用1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前分配空间，如果有初始值就用初始值初始化，如果没有初始值系统用默认值初始化。 2. 修饰普通函数，该函数仅在定义该函数的文件内才能使用。 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，使用类名作用域符号访问，但是在 static 函数内不能访问非静态成员。this指针1. 指向非静态成员的特殊指针。 2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 3. this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值。在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。 4. this 只是一个右值，不能使用&amp;this 5. 在以下场景中，经常需要显式引用 this 指针： 1. 为实现对象的链式引用。 2. 为避免对同一对象进行赋值操作。 3. 在实现一些数据结构时，如 list。inline特征1. 相当于直接执行函数体。 2. 相当于宏操作，但是多了类型检查。 3. 编译器一般不内敛包含循环，递归，switch等复杂操作的inline函数。 4. 在类声明中定义的函数，除了虚函数的其他函数会自动隐式地当成inline函数。使用12345// 类外定义需要显示inlineclass A&#123; void b();&#125;inline void A::b()&#123;&#125;; 编译器对inline函数的处理过程1. 函数体复制到调用点。 2. 为局部变量分配内存空间。 3. 将inline函数中的输入参数和返回值映射到调用方法的局部变量空间。 4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。优劣优点1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 4. 内联函数在运行时可调试，而宏定义不可以。缺点1. 代码膨胀，省去了调用函数的开销。关键在于函数体内执行时间和调用函数开销的平衡。 2. inline函数无法随着函数库升级而升级，inline函数改变需要重新编译，无法直接链接。 3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。tips: virtual可以inline，但是当virtual表示多态性时，不能内联。 inline是编译器建议编译器内联，在程序运行之前，但是多态性的表现在程序运行中。 当编译器明确知道调用对象是哪一个类时，具有实际对象，而不是对象指针或引用，可以使用 inline virtual volatile1volatile int a = 1; 1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 2. volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） 3. const 可以是 volatile （如只读的状态寄存器） 4. 指针可以是 volatile12345678## assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。### 使用```c++# define NDEBUG# cinlude &lt;cassert&gt;assert(p!=NULL); pragma pack(n)强制设定struct,union,class成员变量以n 字节对齐方式。 12#pragma pack(push)#pragma pack(8) 位域1Bit mode:2; 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。 位域内存布局和机器有关 类型必须是整型或者枚举，signed int根据具体实现而定。 取地址和指针不能作用于位域。 extern “C”按照C语言方式编译和链接。extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 1234567#ifdef _cpextern "C"&#123;#endif void *memeset(void *,int ,size_t);#ifdef _cp&#125;#endif structc12345typedef struct a&#123;&#125;s;// 等价于struct a&#123;&#125;;typedef struct a s;// 但两个标识符名称空间不相同。 cpp编译器定位符号的规则改变，首先搜索全局标识符表，如果没有将会搜索类标识符表。 没有同名类 A，可省略struct 12struct A&#123;&#125;;void m(A m); 如果有同名类 A，则A 代表类A，struct A 代表结构体A。 class和struct 本质区别是默认的访问权限，struct默认public,class默认private。 union联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： * 默认权限public * 可以含有析构函数，构造函数 * 不能含有引用类型的成员 * 不能作为derived class，不能作为base class * 不能含有virtual * 匿名union在定义所在的scope可直接访问union member * 匿名union不能包含protected和private member * 全局匿名联合必须是static。explicit 修饰构造函数，防止隐式转换和复制初始化。 修饰转换函数，防止隐式转换，按语境转换除外。123456789101112131415161718192021222324252627282930313233class A&#123; A(int a)&#123;&#125; operator bool() const &#123;return false;&#125;&#125;;class B&#123; B(int b)&#123;&#125; explicit operator bool() const&#123;return false;&#125;&#125;;void getA(A a)&#123;&#125;void getB(B b)&#123;&#125;int main()&#123; A a1(1);//直接初始化 A a2 = 1;//复制初始化 A a3&#123;1&#125;;//直接列表初始化 A a4 = &#123;1&#125;;//复制列表初始化 A a5 = (A)1;//允许static_cast 显示转型 getA(1);//允许int到A的隐式转换 if (a1);//使用转换函数A::operator bool() 的从A到bool的隐式转换 bool a6(a1);//使用转换函数 A::operator bool()的从A到bool的隐式转换 bool a7 = a1;//使用转换函数A::operator bool()的从A到bool的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1);//static_cast 进行直接初始化 B b1(1);//ok B b2 = 1;//false, explitct修饰的构造函数不可复制初始化，不可复制列表初始化 getB(b1);// 被explicit修饰的构造函数的对象不允许你int到B隐式转换 if(b1); bool b6(b1); 被explicit 修饰的转换函数的对象可以按语境转换。 bool b7 = b1; false，被explicit修饰的构造函数的对象不允许B到bool的转型。 bool b8 = static_cast&lt;bool&gt;(b1); return 0;&#125; 引用左值引用常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。引用折叠X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;成员初始化列表有些场合必须要用初始化列表： 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thread]]></title>
    <url>%2F2019%2F07%2F18%2Fthread%2F</url>
    <content type="text"><![CDATA[多进程并发将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。独立的进程可以通过进程间常规的通信渠道传递讯息。 + 缺点 因为OS的保护措施，进程之间的通信通常复杂或者慢。 运行多个进程需要时间启动进程，操作系统需要内部资源来管理进程。 + 优点 OS 在进程间提供附加的保护操作和高级别的通信机制，使得更容易编写安全的并发代码。 可以使用远程连接的方式，在不同的机器上运行独立的进程。多线程并发并发的另一个途径是在单个进程中运行多个线程。线程类似于轻量级的进程。 + 缺点 缺少线程间的数据保护，如果数据要被多个线程访问，我们必须确保每个线程所访问的的数据是一致的，因此需要对线程通信做大量的工作。 + 优点 共享地址空间，缺少数据保护，所以工作量小，多线程开销远小于多进程。C++ 11 std::thread+ C++ 11 引入了&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。+ 声明了 std::atomic和 std::atomic_flag + 生命了一套C风格的原子类型及兼容C的操作函数。+ 声明了 std::thread,std::this_thread+ 声明了相关mutex类。 + std::mutex,std::lock_guard,std::unique_lock.+ 相关condition_variable 类， std::condition_variable和std::condition_variable_any+ std::promise,std::package_task.std 线程类+ std::thread 类的构造函数使用可变参数模板。 1template&lt;typename _Callable, typename... _Args&gt; 1. 函数指针 2. 重载运算符的类对象,仿函数 3. lambda表达式 4. std::function函数指针1234567891011void func1()&#123;&#125;void func2(int i)&#123;&#125;void func3(int i,std::string m)&#123;&#125;std::thread t1(func1);std::thread t2(func2,1);std::thread t3(func3,1,"abc");t1.join();t2.join();t3.join(); 仿函数123456789101112class Fctor &#123;public: // 具有一个参数 void operator() () &#123; &#125;&#125;;Fctor f;std::thread t1(f); std::thread t2(Fctor()); // falsestd::thread t3((Fctor())); // okstd::thread t4&#123;Fctor()&#125;; // ok 一个仿函数类生成的对象，使用起来就像一个函数一样. t2错误，编译器把Fctor()解释为函数声明，并非是临时对象。 在参数添加小括号，进行调用。 使用{}进行构造。 lambda 函数123456std::thread t1([]()&#123; std::cout&lt;&lt;"lambda"&lt;&lt;std::endl;&#125;);//无参std::thread t2([](std::int m)&#123; std::cout&lt;&lt;"lambda"&lt;&lt;m&lt;&lt;std::endl;&#125;,1);//有参 std::fucntion1234567891011121314151617181920212223class A&#123;public: void func1()&#123; &#125; void func2(int i)&#123; &#125; void func3(int i, int j)&#123; &#125;&#125;;A a;std::function&lt;void(void)&gt; f1 = std::bind(&amp;A::func1, &amp;a);std::function&lt;void(void)&gt; f2 = std::bind(&amp;A::func2, &amp;a, 1);std::function&lt;void(int)&gt; f3 = std::bind(&amp;A::func2, &amp;a, std::placeholders::_1);std::function&lt;void(int)&gt; f4 = std::bind(&amp;A::func3, &amp;a, 1, std::placeholders::_1);std::function&lt;void(int, int)&gt; f5 = std::bind(&amp;A::func3, &amp;a, std::placeholders::_1, std::placeholders::_2);std::thread t1(f1);std::thread t2(f2);std::thread t3(f3, 1);std::thread t4(f4, 1);std::thread t5(f5, 1, 2); 构造函数的第一个参数是可调用对象，默认情况下传递的是一个副本。当使用构造函数创建对象的时候，是将参数先赋值给这些变量，所以这些变量只是个副本，然后在线程启动并调用线程入口函数时，传递的参数只是这些副本。 线程对象只能移动不可复制将线程的所有权在std::thread实例间进行转移。1234void f1();void f2();std::thread t1(f1);std::thread t2 = std::move(t1);]]></content>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exception]]></title>
    <url>%2F2019%2F07%2F18%2Fexception%2F</url>
    <content type="text"><![CDATA[中定义了一系列标准的异常。 std::exceptionstd::bad_alloc 该异常可以通过 new 抛出。std::bad_cast 该异常通过dynamic_cast抛出。std::bad_exception std::bad_typeid 该异常可以通过 typeid 抛出。std::logic_error 理论上可以通过读取代码来检测到的异常。std::domain_error 当使用了一个无效的数学域时，会抛出该异常。std::invalid_argument 当使用了无效的参数时，会抛出该异常。std::length_error 当创建了太长的 std::string 时，会抛出该异常。std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。std::runtime_error 理论上不可以通过读取代码来检测到的异常。std::overflow_error 当发生数学上溢时，会抛出该异常。std::range_error 当尝试存储超出范围的值时，会抛出该异常。std::underflow_error 当发生数学下溢时，会抛出该异常。]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memo]]></title>
    <url>%2F2019%2F07%2F15%2Fmemo%2F</url>
    <content type="text"><![CDATA[方法一：暴力法123456789int climb(int i,int n)&#123;if(i&gt;n) return 0;if(i ==n) return 1;return climb(i+1,n)+climb(i+2,n);&#125;int climbs(int n)&#123; return climb(0,n);&#125; 时间复杂度：O(2n)O(2^n)O(2n)。树形递归的大小为 2n2^n2n . 空间复杂度：O(n)。递归树的深度可以达到 nn 方法 2：记忆化递归12345678910111213class Solution&#123; public: climbs(int n)&#123; vector&lt;int&gt; memo; return climbs(0,n,memo); &#125; int climb_memo(int i,int n,vector&lt;int&gt; memo)&#123; if(i&gt;n) return 0; if(i ==n) return 1; if(memo[i]&gt;0) return memo[i]; return climb_memo(i+1,n,memo)+climb_memo(i+2,n,memo); &#125;&#125; 时间复杂度：O(n) 。树形递归的大小可以达到 n. 空间复杂度：O(n) 。递归树的深度可以达到 n. 方法 3：动态规划12345678910111213class Solution&#123; public: climbs(int n)&#123; if(n==1) return 1; &#125; vector&lt;int&gt; dp; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++)&#123; dp[i] = dp[i-1] + dp[i-2] &#125; return dp[n];&#125; 时间复杂度：O(n)，单循环到 n 。 空间复杂度：O(n), dp 数组用了 n 的空间]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 导入conda环境]]></title>
    <url>%2F2019%2F07%2F10%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebook导入conda环境 不使用ipykernel，采用nb_condaconda install nb_conda 注意安装的时候不要激活环境 可以直接在jupyter里面安装包 可以在ipynb里面更改环境]]></content>
      <tags>
        <tag>conda,jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch]]></title>
    <url>%2F2019%2F07%2F02%2Fpytorch%2F</url>
    <content type="text"><![CDATA[torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor) 沿给定dim维度返回输入张量input中 k 个最大值。 如果不指定dim，则默认为input的最后一维。 如果为largest为 False ，则返回最小的 k 个 值。 返回一个元组 (values,indices)，其中indices是原始输入张量input中测元素下标。如果设定布尔值sorted 为_True_，将会确保返回的k 个值被排序。 input (Tensor) – 输入张量 k (int) – “top-k”中的k dim(int, optional) – 排序的维 largest(bool, optional) – 布尔值，控制返回最大或最小值 sorted(bool, optional) – 布尔值，控制返回值是否排序 out(tuple, optional)–可选输出张量 (Tensor, LongTensor) output buffer torch.sort(input, dim=None, descending=False, out=None)-&gt;(Tensor, LongTensor) 对输入张量 input 沿着指定维按升序排序。如果不给定 dim ，则默认为输入的最后一维。如果指定参数 descending 为 True ，则按降序排序 返回tuple(sorted_tensor, sorted_indices) 会改变tensor的函数操作会用一个下划线后缀来标示。比如,torch.FloatTensor.abs_()会在原地计算绝对值，并返回改变后的tensor，而tensor.FloatTensor.abs()将会在一个新的tensor中计算结果。 view()函数作用是将一个多行的Tensor,拼接成一行。 torch.max(x,1 or 0) 返回两个res，第一个是最大值，第二个是对应的索引值；第二个参数 0 代表按列取最大值并返回对应的行索引值，1 代表按行取最大值并返回对应的列索引值。 transpose只能操作2D矩阵的转置。有两种调用方式。连续使用transpose也可实现permute的效果。 torch.index_select(input, dim, index, out=None)-&gt;Tensor w 在指定维度dim方向上从input中抽取由位置序列index所指定的值。output的其他维度的长度和原来矩阵相同，在第dim维度上的长度和index的长度相同。 torch 加法 第一种：a+b 第二种：torch.add(a,b) 第三种：result = torch.Tensor(5,3)torch.add(a,b,out=result) #把运算结果存储在result上 第四种：b.add_(a) #把运算结果覆盖掉b 乘积 Pytorch 的 mm 是矩阵的外积，而dot是元素对应积，即对应位置的元素相乘，需要左右矩阵形状一致。这点和numpy、mxnet不一样。 torch.div(input,value,out=None) -&gt; Tensor #逐元素除 expand(*sizes) -&gt; Tensor expand_as(tensor) == self.expand(tensor.size()) torch.unsqueeze(input, dim=None, out=None) 返回一个新的张量，对输入的制定位置插入维度 1 注意:返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。 将输入张量形状中的1 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)，那么输出形状就为:(A×B×C×D)当给定dim时，那么挤压操作只在给定维度上。例如，输入形状为: (A×1×B), squeeze(input, 0) 将会保持张量不变，只有用 squeeze(input, 1)，形状会变成 (A×B)。 如果dim为负，则将会被转化dim+input.dim()+1 tensor (Tensor) – 输入张量 dim (int) – 插入维度的索引 out (Tensor, optional) – 结果张量]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ptroch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲杂笔记]]></title>
    <url>%2F2019%2F06%2F08%2Fcppnote%2F</url>
    <content type="text"><![CDATA[Cin.get(),返回一个cin对象，会把换行符留在输入队列，若连续输入，可以：使用cin.get()或者cin.get().get(). Delete [] p; 删除整个动态数组。 大多数情况，把数组名解析成地址。但是在sizeof运算中，并不会这样。sizeof运算在数组上，得到的是数组的长度。 auto关键字只能用于单值初始化推断，不能用于初始化列表。 数据成员被初始化的顺序和他们在类声明中的顺序相同，与初始化器中的顺序无关。 赋值符号进行浅拷贝，指向同一地址，不开辟新的内存空间。深拷贝开辟新的内存空间。 new A和new A() 区别 ,当A是POD时，有区别，且C++98和C++03会有区别。在Apple LLVM version 9.0.0 (clang-900.0.38)没有区别。 POD是Plain old data的缩写，它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。 算数表达式中，同时存在unsigned和int，会把int转化为unsigned。无符号数运算结果如何是有符号数会自动转型无符号。 字符型分为，char， signed char，unsigned char. unsigned和signed混合计算，结果不要出现负数。 C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量. ::全局作用符覆盖默认作用域规则。 void *p 可以指向所有类型，但是不能操作内容。 对于string类的输入函数，它会自动忽略开头的空白（空格、制表符、换行等等），从第一个真正的字符开始直到下一个空白。 对于getline()函数，它会保存字符串中的空白符，它读入数据，直到遇到换行符位置。 size_t类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。是unsigned int。 栈解旋:从进入try块到抛出异常之前，栈中构造的所有对象将被析构，析构顺序和构造顺序相反。 栈上：A a();//这里声明了一个函数，没有传入的参数，返回值为类类型A b;//默认调用“对象名()”这个构造函数构造对象A c(1);//默认调用相应的构造函数构造对象堆上:加括号不加括号一般无差别，都调用默认的构造函数(参考条例7) 12 A *d = new A();A *e = new A; 对于内置类型而言:加括号是进行了初始化，不加是未进行初始化 12int *f = new int();int *g = new int; 未完待续 闲杂笔记]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
