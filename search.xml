<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Funcategorized%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2Funcategorized%2Fcomputer_network%2F</url>
    <content type="text"><![CDATA[物理层通信方式模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输链路层基本问题 封装成帧 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 透明传输 透明表示一个实际存在的事物看起来好像不存在一样。帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错检测 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。信道划分 广播信道 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 点对点信道 一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。信道复用技术 频分复用 频分复用的所有主机在相同的时间占用不同的频率带宽资源。 时分复用 时分复用的所有主机在不同的时间占用相同的频率带宽资源。使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 波分复用 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 码分复用 为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片（向量）S和T有 S.T/m = 0；为了讨论方便，取 m=8，设码片S为00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到 当接收端使用码片S对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。CSMA/CD 载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列信息部分的长度不超过 1500MAC 地址MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。局域网局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。可以按照网络拓扑结构对局域网进行分类：以太网以太网是一种星型拓扑结构局域网。早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法；交换机交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了4字节首部VLAN标签，用于表示该帧属于哪一个虚拟局域网。网络层网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 IP数据报 版本 : 有 4（IPv4）和 6（IPv6）两个值; 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。IP地址通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。IP地址= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。注意，外部网络看不到子网的存在。无分类编址 CIDR消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。IP 地址= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 地址解析协议 ARP（Address Resolution Protocol）每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 网际控制报文协议 ICMP（Internet Control Message Protocol）ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。ICMP 报文分为差错报告报文和询问报文。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 路由器路由器从功能上可以划分为：路由选择和分组转发。分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；报告转发分组出错。 路由选择协议自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 若本路由表中不存在目的N的网络，则添加。 若存在跳数更小的，则更新。 若3分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。RIP 协议实现简单，开销小。但是RIP能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 坏消息传播的慢。OSPF开放表示OSPF不受某一家厂商控制,而是公开发表的;最短路径优先表示使用了 Dijkstra 提出的最短路径算法OSPF。OSPF具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。只有当链路状态发生变化时，路由器才会发送信息。所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快. BGPAS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。传输层UDP用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。三次握手假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四次挥手 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由: 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。TCP 可靠传输超时重传机制报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下:其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：其中 RTT_d 为偏差的加权平均值。TCP 流量控制滑动窗口控制。拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 慢开始发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …。cwnd 指数增长。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1，cwnd线性增长。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传和快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。在这种情 况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。应用层域名系统DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。文件传送协议使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。远程登录协议TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP # Web 页面请求过程 ## DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 将该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。 该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的(FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。]]></content>
      <tags>
        <tag>HTTPS</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2Ffoundation%2Foperatoration%2F</url>
    <content type="text"><![CDATA[基本特征 共享-互斥共享和同时共享 并发与并行 虚拟-时（时间）分复用技术和空（空间）分复用技术 异步基本功能进程管理进程与线程 进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 线程是独立调度的基本单位。 区别： 线程不占有资源 同一进程中的线程切换不会导致进程切换 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。切换就绪态，运行态，阻塞态进程调度算法批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 先来先服务 first-come first-serverd（FCFS） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 交互式系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系。 优先度调度 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同。进程在第一个队列没执行完，就会被移到下一个队列。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以看成是时间片轮转调度算法和优先级调度算法的结合。 实时系统实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 同步互斥 对临界资源进行访问的那段代码称为临界区。 管程 同步互斥 进程通信管道管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 12unistd.h int pipe(int fd[2]); 半双工通信。 只能在父子进程和兄弟进程中使用。 FIFO命名管道，去除了管道只能在父子进程中使用的限制 123#include &lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 消息队列 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难。 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法。 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。信号量共享存储套接字共享存储死锁必要条件 资源互斥 占有和等待 不可抢占 死循环处理方法鸵鸟策略死锁检测不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 每种类型一个资源的死锁检测 从一个节点开始深度优先遍历，查找是否存在有向环。 每种类型多个资源的死锁检测上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 递归，直到所有进程均被访问，若存在未被访问进程，则产生死锁。 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复死锁预防破坏4个必要条件 要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。 要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。 资源编号，顺序请求。死锁避免 进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配 银行家算法 安全状态 即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。银行家算法 单个资源的银行家算法 多资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。算法：按照分配矩阵进行分配，寻找小于等于可用资源的行，如果不存在则状态不安全。存在则释放该行继续迭代。状态不安全。 内存管理虚拟内存虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存. 内存碎片 内外碎片 内存分配策略 首次适配 第一个合适的块。 最佳适配 遍历全部空间，差值最小。 最差适配 差值最大。碎片整理 压缩式 交换式虚拟内存 分页系统映射内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 虚拟地址=页号+偏移量页表项最后一位表示是否存在于内存中，1 表示存在.0不存在,则需要进行页面替换.页面置换算法 全局置换算法 工作集 一个进程当前正在使用的逻辑页面集合。 常驻集 指在当前时刻，进程实际驻留在内存当中的页面集合；工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数目，以及所采用的页面置换算法； 当进程常驻集的大小达到某个数目后，再给它分配更多的物理页面，缺页率也不会明显下降 缺页率页面置换算法 常驻集大小可变。例如，每个进程在刚开始运行的时候，先根据程序的大小给它分配一定数目的物理页面，然后在运行过程中，再动态的调整常驻集的大小。 可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以是在其他进程当中，各个并发进程竞争地使用物理页面。 缺页率表示“缺页次数/内存访问次数”（比率）或“缺页的平均时间间隔的倒数” 抖动问题： 如果分配给一个进程的物理页面很少，不能包含整个的工作集，那常驻集含于工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存到外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为“抖动”。 原因: 如果分配给一个进程的物理页面很少，不能包含整个的工作集，那常驻集含于工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存到外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为“抖动”。 局部置换算法OPT Optimal replacement algorithm选择被在此访问时间最长的那一页。是一种理想算法，实际无法实现。FIFO First in First outFIFO 会产生Belady异常（当所分配的物理块数增大而页故障数不减反增的异常现象） 改进的FIFO算法 第二次机会算法 根据FIFO维护一只链表，尾插法，设置标志位R,页面被使用时，R=0。从头开始查找R=1的页面，如果存在说明该页最久未使用，进行置换。如果R=1，则将R=0，将该页面放在尾部。 LRU, Least Recently Used实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。该方法代价较高。 LRU需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。 NRU, Not Recently Used（clock算法） 简单clock算法 维护一个标志位R(read),将内存中所有页面都通过链接指针链接成一个循环队列。换页时，按照FIFO的算法检查将R=O的页面置换。 改进的clock算法 每个页面设置两个标志位，R(read)和M(modify)。被读时，R=1.被修改时，M=1，R=0。 最近未被访问，也未被修改(R=0, M=0)。 最近被访问，但未被修改(R=1, M=0)。 最近未被访问，但被修改(R=0, M=1)。 最近被访问，被修改(R=1, M=1)。12345678910111213141516deque&lt;map&lt;int,int&gt;&gt; *que;auto deque_point = que.begin();while(true)&#123;while(deque_point)&#123; if(R=0,M=0) return; ++deque_point;&#125;while(deque_point)&#123; if(R=0,M=1) return; *deque_point-&gt;M = 0; ++deque_point;&#125;deque_point = que.begin();&#125; 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0). 分段 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 段表 操作系统进行初始化，操作者可以进行后续设置。 段页式—程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 分页与分段 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大 小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 文件管理设备管理磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 FCFS frist come frist served SSTF shortest seek time frist 优先调度与当前磁头所在磁道距离最近的磁道。容易产生饥饿现象。远端请求长时间无法响应。 SCAN 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。单向访问距离最近的磁道。直到该方向上没有未完成的磁盘请求，然后改变方向。 CSCAN 保持最大磁道挨着最小磁道和SCAN相似，但是到达内部之后立即调整到最外层，继续往内。或者相反。 系统调用Linux 系统调用|task|command|| —- | —-||进程控制|fork();exit();wait()||进程通信| pipe(); shmget(); mmap()||文件操作| open(); read();write()||设备操作| ioctl();read();write()||信息维护| getpid(); alarm(); sleep()||安全| chmod();umask();chown()| 内核大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断外中断由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。异常由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。陷入用户系统调用链接装载 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。静态链接 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 在可执行文件中产生一份拷贝。目标文件 可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 动态链接在内存中一般只保留该编译单元的一份拷贝。 装载时动态链接(Load-time Dynamic Linking)：这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，调用函数的时候利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中(全部函数加载进内存），其主要目的是便于代码共享。（动态加载程序，处在加载阶段，主要为了共享代码，共享代码内存） 运行时动态链接(Run-time Dynamic Linking)：这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，将其加载到内存中（只加载调用的函数进内存），并标识内存地址，其他程序也可以使用该程序，并用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址。（dll在内存中只存在一份，处在运行阶段）]]></content>
      <categories>
        <category>foundation</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2Funcategorized%2Fsql%2F</url>
    <content type="text"><![CDATA[SELECT col,col,col 找什么？FROM table 从哪找？WHERE col 条件 条件是啥？ 条件：数字(where)当查找条件col是数字 select * from table where col = 1; Operator Condition SQL Example 解释 , !=, &lt; &lt;=, &gt;, &gt;= Standard numerical operators col != 4 等于 大于 小于 BETWEEN … AND … Number is within range of two values (inclusive) col BETWEEN 1.5 AND 10.5 在 X 和 X之间 NOT BETWEEN … AND … Number is not within range of two values (inclusive) co NOT BETWEEN 1 AND10 不在 X 和 X之间 IN (…) Number exists in a list col IN (2, 4, 6) 在 X 集合 NOT IN (…) Number does not exist in a list col NOT IN (1, 3, 5) 不在 X 集合 ## 条件：文本(where) 当查找条件col是文本 select * from table where col like ‘%jin’; Operator Condition SQL Example 解释 = Case sensitive exact string comparison (notice the single equals) col = “abc” 等于 != or &lt;&gt; Case sensitive exact string inequality comparison col != “abcd” 不等于 LIKE Case insensitive exact string comparison col LIKE “ABC” 等于 NOT LIKE Case insensitive exact string inequality comparison col NOT LIKE “ABCD” 不等于 % Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) col LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) 模糊匹配 _ Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) col LIKE “AN_” (matches “AND”, but not “AN”) 模糊匹配单字符 IN (…) String exists in a list col IN (“A”, “B”, “C”) 在集合 NOT IN (…) String does not exist in a list co NOT IN (“D”, “E”, “F”) 不在集合 ## 排序(rows) 需要对结果rows排序和筛选部分rows select * from table where col &gt; 1 order by col asc limit 2 offset 2 Operator Condition SQL Example 解释 ORDER BY . ORDER BY col ASC/DESC 按col排序 ASC . ORDER BY col ASC/DESC 升序 DESC . ORDER BY col ASC/DESC 降序 LIMIT OFFSET . LIMIT num_limit OFFSET ORDER BY . ORDER BY col1 ASC,col2 DESC 多列排序 ## join:连表(table) 当查找的数据在多张关联table里 select * from table1 left join table2 on table1.id = table2.id where col &gt; 1 Operator Condition SQL Example 解释 JOIN .. ON .. . t1 JOIN t2 ON t1.id = t2.id 按ID连成1个表 INNER JOIN . t1 INNER JOIN t2 ON t1.id = t2.id 只保留id相等的row LEFT JOIN . t1 LEFT JOIN t2 ON t1.id = t2.id 保留t1的所有row RIGHT JOIN . t1 RIGHT JOIN t2 ON t1.id = t2.id 保留t2的所有row IS/IS NOT NULL . col IS/IS NOT NULL col是不是为null ## 算式(select / where) 当需要对select的col 或 where条件的col 经过一定计算后才能使用 select ,col2 from table where col/2 &gt; 1 Operator Condition SQL Example 解释 + - * / % . col1 + col2 col加减乘除 substr . substr(col,0,4) 字符串截取 AS . col * 2 AS col_new col取别名 ## 统计（select） 对查找的rows需要按col分组统计的情况 select count(*),avg(col),col from table where col &gt; 1 group by col Operator Condition SQL Example 解释 COUNT(*), COUNT(column) A common function used to counts the number of rows in the group if no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column. count(col) 计数 MIN(column) Finds the smallest numerical value in the specified column for all rows in the group. min(col) 最小 MAX(column) Finds the largest numerical value in the specified column for all rows in the group. max(col) 最大 AVG(column) Finds the average numerical value in the specified column for all rows in the group. avg(col) 平均 SUM(column) Finds the sum of all numerical values in the specified column for the rows in the group. sum(col) 求和 GROUP BY . group by col,col2 分组 HAVING . HAVING col&gt;100 分组后条件 子表 (table)一次select的结果rows作为下一次select的临时table才能得到最终结果 select * from (select * from table where col &gt; 1) as tmp where col &lt; 1 Operator Condition SQL Example 解释 （select -）as tmp （select -）as tmp select结果做子表 in（select -） in（select -） select结果做条件 avg（select -） avg（select -） select结果做条件]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++2.0]]></title>
    <url>%2Funcategorized%2FCpp11%2F</url>
    <content type="text"><![CDATA[auto auto不能用来声明函数的返回值。但是如果函数有一个尾随的返回类型，auto是可以声明返回值。1234template&lt;class T1, class T2&gt;auto test(T1 t1,T2 t2) -&gt; **decltype**(t1 + t2)&#123; return t1+t2;&#125; std::array array对象的长度是固定的，使用了静态存储区，即存储在栈上，效率跟数组相同，但是更加的安全。 nullptr nullptr-&gt;void* nullptr是std::nullptr_t。存在和任何指针类型以及类成员指针类型的空值，bool类型的隐式转换。 不存在整型的隐式转换。12345678910f(int *p)&#123;&#125;f1(bool o)&#123;&#125;f2(std::share_ptr&lt;int&gt; p)&#123;&#125; int p1 = NULL;int p2 = nullptr;if(p1==p2);f(p2);f1(p2);f2(p2);int i = nullptr; //false 基于范围的for循环12345678910111213for ( val declare : collection ) statementfor(int e : arr)&#123; e = e*e; std::cout&lt;&lt;e&lt;&lt;std::endl;&#125;template&lt;class InputIterator, class Function&gt; Function for_each( InputIterator _First, InputIterator _Last, Function _Func ); override final override:表示函数应当重写基类中的虚函数。（纯虚函数，抽象类） final:表示派生类不应当重写这个虚函数。123456789101112131415161718class A&#123; public: virtual void func(int i)&#123; cout&lt;&lt;"A::f"&lt;&lt;endl; &#125;&#125;;class B : public A&#123; public: virtual void func(long l) final &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;;class C : public A&#123; public: virtual void func(int i) override &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;; 强类型枚举 传统enum会将常量暴露在外层作用域。存在隐式整型转型。 强类型枚举由关键字enum class标识，不存在隐式转整型。12enum class a&#123;one,two,all&#125;;a ob = a::one; variadic templates 可变参数列表, 类型和个数任意1234567891011template &lt;class T, class... Args&gt;void print(const T &amp;first, const Args &amp;... args)&#123; cout&lt;&lt;first&lt;&lt;endl; print(args...);&#125;void print()&#123;&#125;template&lt; class...T&gt;void print(const Args &amp;... args)&#123; /**/&#125; 智能指针 pointer-like classess#include&lt;memoray&gt; 智能指针构造函数是explicit,拒绝内置指针隐式转换为智能指针。 shared_ptr&lt;T&gt; 可以指向同一地址空间，通过count计数，防止成为空悬指针。 unique_ptr&lt;T&gt; 独占内存空间。 不要使用get()初始化指针，会产生未定义行为。 常用共有函数列表 p.get() 返回内置指针。 swap(a,b) a.swap() 交换指针 shared_ptr&lt;T&gt; p 独有函数 make_shared&lt;T&gt;(arg) 返回一个指针 指向用arg初始化的对象。 shared_ptr&lt;T&gt; p(q) 拷贝构造函数赋值。 p.unique()-&gt;bool p.use_count()-&gt;int 123456shared_ptr&lt;double&gt;pd;double *p_reg = new double;pd = p_reg;//错误，不允许隐式转换pd = shared_ptr&lt;double&gt;(p_reg);//正确shared_ptr&lt;double&gt; pshared = p_reg;//错误，不允许隐式转换shared_ptr&lt;double&gt; pshared(p_reg);//正确 不能将smart point 应用非堆内存. auto_ptr&lt;T&gt; p(new T); 旧版本的auto_ptr，尽量用新智能指针替代。unique_ptr&lt;T&gt; p(new T); unique_ptr&lt;T&gt; 拒绝拷贝和赋值。但可以通过u.reset() .u.release()间接拷贝和赋值。 release()-&gt;pointer u.reset(m) 提供可选指针参数列表，u = m 12345678910template &lt; class T&gt;class shared_ptr&#123; private: T *p; public: shared_ptr(T *pm):p(pm)&#123;&#125; T&amp; operator*() const&#123;return *p;&#125; T* operator-&gt;() const&#123;return p;&#125;&#125;;//-&gt;运算符作用之后得到的输出继续用-&gt;作用。 迭代器 pointer-like classes12345678910111213141516171819template&lt; class T&gt;struct __list_node&#123; void *prev; void *next; T data;&#125;;template&lt; class T,class Ref, class Ptr&gt;class __list_iterator&#123; typedef __list_iterator&lt;T,Ref,Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; link_type node; bool operator==(const self&amp;x)const&#123; return node == x.node; &#125; reference operator*() const &#123;return (*node).data;&#125; pointer operator-&gt;() const &#123;return &amp;(operator*());&#125;&#125; std::bind 将函数、成员函数和闭包转成function函数对象 将多元(n&gt;1)函数转成一元函数或者(n-1)元函数 123456789101112template&lt; class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );template&lt; class R, class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args ); auto x1 = bind(f,10,20,10); auto x2 = bind(f,std::placeholders::_1,2,3); auto x3 = bind(f,std::placeholders::_1,23,std::placeholders::_2); auto x4 = bind&lt;double&gt;(f,std::placeholders::_1,std::placeholders::_2,5); cout&lt;&lt;x1()&lt;&lt;endl; cout&lt;&lt;x2(1)&lt;&lt;endl; cout&lt;&lt;x3(20,32)&lt;&lt;endl; cout&lt;&lt;x4(23,12)&lt;&lt;endl; 某些无法拷贝的参数，只能使用引用传递，需要使用ref 1for_each(words.begin(),words.end,bind(print,ref(os),_1,' ')); bind 无法绑定重载函数,因为重载函数参数个数不同。 bind 绑定成员函数，需要类的实例作为第二个参数。 bind 绑定成员函数，不需要类实例。 123A a();auto m = bind(&amp;A::f(),a);m(); cast const_cast ‘const_cast’ 这个操作符可以去掉变量const属性或者volatile属性的转换符,消除对象的常量性. static_cast ‘static_cast’允许执行任意的隐式转换和相反转换动作,但没有运行时类型检查来保证转换的安全性. dynamic_cast ‘dynamic_cast’只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程,如果基类没有虚函数，也就无法判断一个基类指针变量所指对象的真实类型, 这时候dynamic_cast只能用来做安全的转换（upercasting），如从派生类指针转换成基类指针，而这种转换其实并不需要dynamic_cast参与。. 如果一个引用类型执行了类型转换并且这个转换是不可能的 reinterpret_cast 是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。这个操作符能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。 在上行转换中，static_cast和dynamic_cast效果是一样的，而且都比较安全，因为向上转换的对象一般是指向子类对象的子类类型指针；而在下行转换中，由于可以定义就不同了指向子类对象的父类类型指针，同时static_cast只在编译时进行类型检查，而dynamic_cast是运行时类型检查，则需要视情况而定. 未完待续 –…-….-…- -.-..—–.—- -…….——.- -.-.-…..-…- -.——……. -..—……… -..—…-.-.-. -..—.-.—.-. ——–….–.. —-.—……. -.-..–.-.-.-.- ——–….–.. ——.-.-.—- —–..-.—..- –……….-. —-..-.-.—.- -……—-.-.-. -.—.—–…- —.-.-…—– –..-.—-..-.- -.——–.-.– -..—..-.-…. –……….-.]]></content>
      <tags>
        <tag>c++</tag>
        <tag>未完待续</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据结构整理]]></title>
    <url>%2Ffoundation%2Fdatastructure%2F</url>
    <content type="text"><![CDATA[顺序结构顺序栈12345678910111213template &lt;class T&gt;class sq_stack&#123;private: T val; int top; int size;public: sq_stack(); ~sq_stack(); T pop(); void insert(T val); int get_size(sq_stack s);&#125; 队列1234567891011121314template&lt;class T&gt;class sq_queue&#123;private: T val; int front; int rear; int maxsize;public: sq_queue(); ~sq_queue(); int get_rear(sq_queue r); int get_front(sq_queue f); void insert(T val);&#125; 顺序表123456template &lt;class T&gt;class sq_list&#123; vector&lt;T&gt; a; int length; int size;&#125; 链式结构## 12345678910111213template &lt;class T&gt;class link_node&#123;private: T data; link_node *next;public: link_node(T d):data(d),next(nullptr)&#123;&#125; ~link_node();&#125;typedef struct Lnode&#123; elemtype data; struct Lnode *next;&#125;Lnode,*LinkList; 哈希表 哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突解决方法链地址法：key相同用单链表链接开放定址法： 线性探测法：放到key的下一个位置，Hi = (H(key) + i) % m 二次探测法：Hi = (H(key) + i) % m 随机探测法：Hi= (H(key) + 伪随机数) % m 123456789101112typedef char KeyType;typedef struct&#123; KeyType key;&#125;RcdType;typedef struct&#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 🌲二叉🌲存储结构 顺序存储 链式存储遍历方式 先序 后序 中序 层次实现1234567891011121314template &lt;class T&gt;class binary_node&#123;private: binary_node *left; binary_node *right; T val;public: binary_node(int x):val(x),left(nullptr),right(nullptr)&#123;&#125; ~binary_node(); void in_order(binary_node *root); void pre_order(binary_node *root); void post_order(binary_node *root); void level_order(binary_node *root);&#125; 类型 满二叉🌲 完全二叉🌲(堆) 大根堆 小根堆 二叉查找🌲(排序🌲) 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找的最大次数等于数的高度。缺点(多次插入偏向一边的数据，会导致🌲严重不平衡) 平衡二叉🌲(AVL) 平衡因子BF 左高-右高 ,根节点BF&gt;1 右旋 顺时针 &lt;-1 左旋 插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作 最小失衡🌲(平衡二叉树插入新的节点导致失衡的子🌲):调整策略 LL 左孩子右旋 RR 右孩子左旋 LR 左孩子左旋，再右旋 RL 右孩子的左子🌲先右旋，在左旋红黑🌲解决了二叉查找树的不平衡问题。最大查找次数不会超过最短路径的两倍。主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率高。 节点是红色或黑色。 根节点为黑色。 所有的叶子节点都是黑色的空节点。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。自平衡 变色 旋转 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667enum tree_color(RED,BLACK);template &lt;class T&gt;class rb_node&#123;public: tree_color color; T key; rb_node *left; rb_node *right; rb_node *parent; rb_node(T val,rb_color c,rb_node l,rb_node r,rb_node p):key(val),color(c),left(l),right(r),parent(p)&#123;&#125;&#125;;template &lt;class T&gt;class rb_tree&#123; rb_tree(); ~rb_tree(); void pre_order(); void in_order(); void post_order(); rb_node&lt;T&gt;* re_search(T key); //递归查找 rb_node&lt;T&gt;* iter_serach(T key); //非递归 T minkey(); T maxkey(); rb_node&lt;T&gt;* successor(rb_node&lt;T&gt; *x); rb_node&lt;T&gt;* predecessor(rb_node&lt;T&gt; *x); void insert(T key); void remove(T key); void destory(); void print();private: void left_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x); void right_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x);&#125;## B🌲* m阶B🌲 1. 每个结点最多有m-1个关键字 2. 根结点最少可以只有1个关键字 3. 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它 4. 根结点到每个叶子结点高度相同 5. 非根结点至少有Math.ceil(m/2)-1个关键字![a](B_tree)### 实现```c++template &lt;class T&gt;struct B_tree_node &#123; int n; vector&lt;T&gt; *key; bool is_leaf; struct B_tree_node *parent; vector&lt;B_tree_node *&gt; *child;&#125;;template &lt;class T&gt;class B_tree&#123;private: B_tree_node&lt;T&gt;* root; int m;public: B_tree(int tVal = 2); ~B_tree(); B_tree_node&lt;T&gt;* search_tree(B_tree_node&lt;T&gt;* root, T k ,int &amp;index); B_tree_node&lt;T&gt;* getRoot(); void insert(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); void delete(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); T get_value(B_tree_node&lt;T&gt;* root,T value);&#125;; B+ M阶B+🌲 内结点存有关键字和指向孩子结点指针。外结点存有关键字和数据。 叶子结点还有关键字，按照关键字大小排序，叶子结点中存在指向兄弟结点的指针。 一颗B+🌲存在两个指针，一个指向根结点，一个指向存有最小关键字的结点。 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引。 所有数据均存储在叶子结点中。123456789101112template &lt;class T&gt;class bp_node&#123; public: bp_node(); virtual ~bp_node(); private: T data;&#125;;template &lt;class T&gt;class inter_node: public bp_node&#123; public:&#125; 八叉树图排序查找递归折半查找归并查找快速排序迭代折半查找归并查找]]></content>
      <categories>
        <category>foundation</category>
      </categories>
      <tags>
        <tag>未完待续</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++杂乱笔记2]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_two%2F</url>
    <content type="text"><![CDATA[OOP 多态 C++多态分类及其实现 重载多态(Ad-hoc Polymorphism,编译期) 函数重载，运算符重载 子类型多态(Subtype Polymorphism,运行期) 虚函数 参数多态性(Parametric PolyMorphism) 编译期 类模板，函数模板 强制多态(Coerion PolyMorphism 编译期,运行期) 类型转换 静态多态（编译期间，早绑定） 函数重载,模板动态多态（运行期间，晚绑定） 虚函数 多态与非多态的实质区别就是函数地址是早绑定还是晚绑定 tips: 普通函数不可是virtual static 不可为virtual 构造函数不可为virtual,因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针 tips:C++ 隐藏 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）. 虚函数指针相关虚函数指针和虚函数表 A b;父类虚函数表 包含虚函数的类才会有虚函数表， 同属于一个类的对象共享虚函数表， 但是有各自的虚函数指针.虚函数表实质是一个指针数组，里面存的是虚函数的函数指针。 虚表指针放在类成员中的第一个地址(C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（)，可以通过(long)(&amp;b) 访问虚表地址，(long)(long)(&amp;b) 访问第一个第一个虚函数地址。123pFun = (Fun)*((int*)*(int*)(&amp;b));pFun();reinterpret_cast&lt;Fun&gt;(*((long *)*(long *)(&amp;d)))(); 单继承，不重写虚函数单继承，重写虚函数多继承，不重写虚函数多继承，重写虚函数 virtual ~f()作用 * 解决based point-&gt; derived object,用based point 删除derived object. * 如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数.虚继承虚继承用于解决多继承条件下的菱形继承问题(费存储空间、存在二义性) * 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4字节）和虚基类表(不占用类对象的存储空间)(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了);当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 * 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。虚函数和虚继承 都使用了虚指针(占用类的存储空间)和虚表（不占类存储空间） 虚函数表存储的是虚函数地址，虚基类表存储相对直接继承类的位偏移。 虚基类在子类中存在一份拷贝，而虚函数不占用存储空间。 tips: 模板类可以使用虚函数。 但任何类的成员模板函数不能是虚函数。 聚合类用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配管理 malloc 申请指定字节内存，初始值不确定。 char *str = (char*) malloc(100); calloc 为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc 更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca 在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 new/new[]先底层调用malloc，然后调用构造函数。 delete/delete[]先调用析构函数，然后free，指针置为空。 new能自动计算所需字节数，无需像malloc一样手动操作。 pacement new允许传递额外的地址参数，预先在指定的内存区域创建对象。 123456new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list&#125;//place_address 为 point//initializers可能为空的初始化列表 tips: delete this 合法前提 之后不再调用this指针(任何调用) this对象由new而不是其他任何方式分配的。 该成员函数是this对象最后调用的的成员函数。 剩下的成员函数（delete this之后的)不接触到this对象,包括调用任何其他成员函数或访问任何数据成员。 只在堆上生成对象的类方法：将析构函数私有。 (C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。) 在栈上建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。 只在栈上生成对象的类方法：将new和delete操作符重载为私有。 ：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++杂乱笔记1]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_one%2F</url>
    <content type="text"><![CDATA[const(不可变)作用1. 修饰常量 2. 修饰指针 指针常量和常量指针 3. 常量引用 避免拷贝，避免对值的修改，不能使用非const引用指向const对象。 4. 修饰成员函数 函数内部不能修改成员函数使用123456789101112131415161718192021const int a1;int get() const;const char* p1 = a2;//常量指针，指向常量的指针，保护指向的地址空间数据不可变。指针可变，可以修改const指针所指向的值的，但是不能通过const对象指针来进行，自以为指向const的指针。char* p = a2;*p = a3;char* const p2 = a3;//指针常量， 保护指针，指针自身的地址空间不可变，数据可变。//不能把常量的地址赋给指针变量void get(const int val);void get(const int *val);void get(int *const val);//file1.cppint cout;const int cout2;extern const int cout3;//file2.cppextern int cout; //在全局作用域里定义非const变量时，它在整个程序中都可以访问cout++;cout2; //error除非特别说明，在全局作用域声明的const变量是定义该对象的文件的局部变量，只存在于那个文件，不能被其他文件访问。extern const int cout3;cout3++; static()作用1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前分配空间，如果有初始值就用初始值初始化，如果没有初始值系统用默认值初始化。 2. 修饰普通函数，该函数仅在定义该函数的文件内才能使用。 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，使用类名作用域符号访问，但是在 static 函数内不能访问非静态成员。this指针1. 指向非静态成员的特殊指针。 2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 3. this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值。在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。 4. this 只是一个右值，不能使用&amp;this. 5. 在以下场景中，经常需要显式引用 this 指针： 1. 为实现对象的链式引用。 2. 为避免对同一对象进行赋值操作。 3. 在实现一些数据结构时，如 list。inline特征1. 相当于直接执行函数体。 2. 相当于宏操作，但是多了类型检查。 3. 编译器一般不内敛包含循环，递归，switch等复杂操作的inline函数。 4. 在类声明中定义的函数，除了虚函数的成员函数会自动隐式地当成inline函数。使用12345// 类外定义需要显示inlineclass A&#123; void b();&#125;inline void A::b()&#123;&#125;; 编译器对inline函数的处理过程1. 函数体复制到调用点。 2. 为局部变量分配内存空间。 3. 将inline函数中的输入参数和返回值映射到调用方法的局部变量空间。 4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。优劣优点1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 4. 内联函数在运行时可调试，而宏定义不可以。缺点1. 代码膨胀，省去了调用函数的开销。关键在于函数体内执行时间和调用函数开销的平衡。 2. inline函数无法随着函数库升级而升级，inline函数改变需要重新编译，无法直接链接。 3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。tips: virtual可以inline，但是当virtual表示多态性时，不能内联。 inline是编译器建议编译器内联，在程序运行之前，但是多态性的表现在程序运行中。 当编译器明确知道调用对象是哪一个类时，具有实际对象，而不是对象指针或引用，可以使用 inline virtual123456789101112class A&#123; public: virtual void foo()&#123;&#125;;&#125;class B:A&#123; public: virtual void foo()&#123;&#125;;&#125;A *a = new B();a-&gt;B::foo();delete a;a = nullptr; volatile1volatile int a = 1; 1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 2. volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） 3. const 可以是 volatile （如只读的状态寄存器） 4. 指针可以是 volatile12345678## assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。### 使用```c++# define NDEBUG# cinlude &lt;cassert&gt;assert(p!=NULL); pragma pack(n)强制设定struct,union,class成员变量以n 字节对齐方式。 12#pragma pack(push)#pragma pack(8) 位域1Bit mode:2; 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。 位域内存布局和机器有关 类型必须是整型或者枚举，signed int根据具体实现而定。 取地址和指针不能作用于位域。 extern “C”按照C语言方式编译和链接。extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 1234567#ifdef _cpextern "C"&#123;#endif void *memeset(void *,int ,size_t);#ifdef _cp&#125;#endif structc12345typedef struct a&#123;&#125;s;// 等价于struct a&#123;&#125;;typedef struct a s;// 但两个标识符名称空间不相同。 cpp编译器定位符号的规则改变，首先搜索全局标识符表，如果没有将会搜索类标识符表。 没有同名类 A，可省略struct 12struct A&#123;&#125;;void m(A m); 如果有同名类 A，则A 代表类A，struct A 代表结构体A。 class和struct 本质区别是默认的访问权限，struct默认public,class默认private。 union联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： * 默认权限public * 可以含有析构函数，构造函数 * 不能含有引用类型的成员 * 不能作为derived class，不能作为base class * 不能含有virtual * 匿名union在定义所在的scope可直接访问union member * 匿名union不能包含protected和private member * 全局匿名联合必须是static。explicit 修饰构造函数，防止隐式转换和复制初始化。 修饰转换函数，防止隐式转换，按语境转换除外。 按语境转换 if、while、for 的控制表达式； 内建逻辑运算符 !、&amp;&amp; 和 || 的操作数； 条件运算符 ?: 的首个操作数； static_assert 声明中的谓词； noexcept 说明符中的表达式；12345678910111213141516171819202122232425262728293031class A&#123; A(int a)&#123;&#125; operator bool() const &#123;return false;&#125;&#125;;class B&#123; B(int b)&#123;&#125; explicit operator bool() const&#123;return false;&#125;&#125;;void getA(A a)&#123;&#125;void getB(B b)&#123;&#125;int main()&#123; A a1(1);//直接初始化 A a2 = 1;//复制初始化 A a3&#123;1&#125;;//直接列表初始化 A a4 = &#123;1&#125;;//复制列表初始化 A a5 = (A)1;//允许static_cast 显示转型 getA(1);//允许int到A的隐式转换 if (a1);//使用转换函数A::operator bool() 的从A到bool的隐式转换 bool a6(a1);//使用转换函数 A::operator bool()的从A到bool的隐式转换 bool a7 = a1;//使用转换函数A::operator bool()的从A到bool的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1);//static_cast 进行直接初始化 B b1(1);//ok B b2 = 1;//false, explitct修饰的构造函数不可复制初始化，不可复制列表初始化 getB(b1);// 被explicit修饰的构造函数的对象不允许你int到B隐式转换 if(b1); bool b6(b1); //被explicit 修饰的转换函数的对象可以按语境转换。 bool b7 = b1; false，被explicit修饰的构造函数的对象不允许B到bool的转型。 bool b8 = static_cast&lt;bool&gt;(b1); return 0;&#125; 引用1) 左值引用声明符：声明 S&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的左值引用。 2) 右值引用声明符：声明 S&amp;&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的右值引用。 * 不存在 void 的引用，也不存在引用的引用,引用的数组,指向引用的指针. * 引用坍缩：容许通过模板或 typedef 中的类型操作构成引用的引用，这种情况下适用引用坍缩（reference coolapsing）规则：右值引用的右值引用 坍缩成右值引用，所有其他组合均 坍缩成左值引用; * 当函数的返回值是左值引用时，函数调用表达式成为左值表达式：1234567typedef int&amp; lref;typedef int&amp;&amp; rref;int n;lref&amp; r1 = n; // r1 的类型是 int&amp;lref&amp;&amp; r2 = n; // r2 的类型是 int&amp;rref&amp; r3 = n; // r3 的类型是 int&amp;rref&amp;&amp; r4 = 1; // r4 的类型是 int&amp;&amp; 左值引用常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 右值引用可用于为临时对象延长生存期（左值引用亦能延长临时对象生存期，但不能通过左值引用修改）成员初始化列表有些场合必须要用初始化列表： 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 导入conda环境]]></title>
    <url>%2Funcategorized%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebook导入conda环境 不使用ipykernel，采用nb_condaconda install nb_conda 注意安装的时候不要激活环境 可以直接在jupyter里面安装包 可以在ipynb里面更改环境]]></content>
      <tags>
        <tag>conda</tag>
        <tag>jupyter</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
</search>
