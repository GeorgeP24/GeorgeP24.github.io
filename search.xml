<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[thread]]></title>
    <url>%2F2019%2F07%2F18%2Fthread%2F</url>
    <content type="text"><![CDATA[多进程并发将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。独立的进程可以通过进程间常规的通信渠道传递讯息。 + 缺点 因为OS的保护措施，进程之间的通信通常复杂或者慢。 运行多个进程需要时间启动进程，操作系统需要内部资源来管理进程。 + 优点 OS 在进程间提供附加的保护操作和高级别的通信机制，使得更容易编写安全的并发代码。 可以使用远程连接的方式，在不同的机器上运行独立的进程。多线程并发并发的另一个途径是在单个进程中运行多个线程。线程类似于轻量级的进程。 + 缺点 缺少线程间的数据保护，如果数据要被多个线程访问，我们必须确保每个线程所访问的的数据是一致的，因此需要对线程通信做大量的工作。 + 优点 共享地址空间，缺少数据保护，所以工作量小，多线程开销远小于多进程。C++ 11 std::thread+ C++ 11 引入了&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。+ 声明了 std::atomic和 std::atomic_flag + 生命了一套C风格的原子类型及兼容C的操作函数。+ 声明了 std::thread,std::this_thread+ 声明了相关mutex类。 + std::mutex,std::lock_guard,std::unique_lock.+ 相关condition_variable 类， std::condition_variable和std::condition_variable_any+ std::promise,std::package_task.std 线程类+ std::thread 类的构造函数使用可变参数模板。 1template&lt;typename _Callable, typename... _Args&gt; 1. 函数指针 2. 重载运算符的类对象,仿函数 3. lambda表达式 4. std::function函数指针1234567891011void func1()&#123;&#125;void func2(int i)&#123;&#125;void func3(int i,std::string m)&#123;&#125;std::thread t1(func1);std::thread t2(func2,1);std::thread t3(func3,1,"abc");t1.join();t2.join();t3.join(); 仿函数123456789101112class Fctor &#123;public: // 具有一个参数 void operator() () &#123; &#125;&#125;;Fctor f;std::thread t1(f); std::thread t2(Fctor()); // falsestd::thread t3((Fctor())); // okstd::thread t4&#123;Fctor()&#125;; // ok 一个仿函数类生成的对象，使用起来就像一个函数一样. t2错误，编译器把Fctor()解释为函数声明，并非是临时对象。 在参数添加小括号，进行调用。 使用{}进行构造。 lambda 函数123456std::thread t1([]()&#123; std::cout&lt;&lt;"lambda"&lt;&lt;std::endl;&#125;);//无参std::thread t2([](std::int m)&#123; std::cout&lt;&lt;"lambda"&lt;&lt;m&lt;&lt;std::endl;&#125;,1);//有参 std::fucntion1234567891011121314151617181920212223class A&#123;public: void func1()&#123; &#125; void func2(int i)&#123; &#125; void func3(int i, int j)&#123; &#125;&#125;;A a;std::function&lt;void(void)&gt; f1 = std::bind(&amp;A::func1, &amp;a);std::function&lt;void(void)&gt; f2 = std::bind(&amp;A::func2, &amp;a, 1);std::function&lt;void(int)&gt; f3 = std::bind(&amp;A::func2, &amp;a, std::placeholders::_1);std::function&lt;void(int)&gt; f4 = std::bind(&amp;A::func3, &amp;a, 1, std::placeholders::_1);std::function&lt;void(int, int)&gt; f5 = std::bind(&amp;A::func3, &amp;a, std::placeholders::_1, std::placeholders::_2);std::thread t1(f1);std::thread t2(f2);std::thread t3(f3, 1);std::thread t4(f4, 1);std::thread t5(f5, 1, 2); 构造函数的第一个参数是可调用对象，默认情况下传递的是一个副本。当使用构造函数创建对象的时候，是将参数先赋值给这些变量，所以这些变量只是个副本，然后在线程启动并调用线程入口函数时，传递的参数只是这些副本。 线程对象只能移动不可复制将线程的所有权在std::thread实例间进行转移。1234void f1();void f2();std::thread t1(f1);std::thread t2 = std::move(t1);]]></content>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exception]]></title>
    <url>%2F2019%2F07%2F18%2Fexception%2F</url>
    <content type="text"><![CDATA[中定义了一系列标准的异常。 std::exceptionstd::bad_alloc 该异常可以通过 new 抛出。std::bad_cast 该异常通过dynamic_cast抛出。std::bad_exception std::bad_typeid 该异常可以通过 typeid 抛出。std::logic_error 理论上可以通过读取代码来检测到的异常。std::domain_error 当使用了一个无效的数学域时，会抛出该异常。std::invalid_argument 当使用了无效的参数时，会抛出该异常。std::length_error 当创建了太长的 std::string 时，会抛出该异常。std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。std::runtime_error 理论上不可以通过读取代码来检测到的异常。std::overflow_error 当发生数学上溢时，会抛出该异常。std::range_error 当尝试存储超出范围的值时，会抛出该异常。std::underflow_error 当发生数学下溢时，会抛出该异常。]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memo]]></title>
    <url>%2F2019%2F07%2F15%2Fmemo%2F</url>
    <content type="text"><![CDATA[方法一：暴力法12345678910int climb(int i,int n)&#123;if(i&gt;n) return 0;if(i ==n) return 1;return climb(i+1,n)+climb(i+2,n);&#125;int climbs(int n)&#123; return climb(0,n);&#125; 时间复杂度：O(2n)O(2^n)O(2n)。树形递归的大小为 2n2^n2n . 空间复杂度：O(n)。递归树的深度可以达到 nn 方法 2：记忆化递归12345678910111213class Solution&#123; public: climbs(int n)&#123; vector&lt;int&gt; memo; return climbs(0,n,memo); &#125; int climb_memo(int i,int n,vector&lt;int&gt; memo)&#123; if(i&gt;n) return 0; if(i ==n) return 1; if(memo[i]&gt;0) return memo[i]; return climb_memo(i+1,n,memo)+climb_memo(i+2,n,memo); &#125;&#125; 时间复杂度：O(n) 。树形递归的大小可以达到 n. 空间复杂度：O(n) 。递归树的深度可以达到 n. 方法 3：动态规划12345678910111213class Solution&#123; public: climbs(int n)&#123; if(n==1) return 1; &#125; vector&lt;int&gt; dp; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++)&#123; dp[i] = dp[i-1] + dp[i-2] &#125; return dp[n];&#125; 时间复杂度：O(n)，单循环到 n 。 空间复杂度：O(n), dp 数组用了 n 的空间]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 导入conda环境]]></title>
    <url>%2F2019%2F07%2F10%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebook导入conda环境 不使用ipykernel，采用nb_condaconda install nb_conda 注意安装的时候不要激活环境 可以直接在jupyter里面安装包 可以在ipynb里面更改环境]]></content>
      <tags>
        <tag>conda,jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch]]></title>
    <url>%2F2019%2F07%2F02%2Fpytorch%2F</url>
    <content type="text"><![CDATA[torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor) 沿给定dim维度返回输入张量input中 k 个最大值。 如果不指定dim，则默认为input的最后一维。 如果为largest为 False ，则返回最小的 k 个 值。 返回一个元组 (values,indices)，其中indices是原始输入张量input中测元素下标。如果设定布尔值sorted 为_True_，将会确保返回的k 个值被排序。 input (Tensor) – 输入张量 k (int) – “top-k”中的k dim(int, optional) – 排序的维 largest(bool, optional) – 布尔值，控制返回最大或最小值 sorted(bool, optional) – 布尔值，控制返回值是否排序 out(tuple, optional)–可选输出张量 (Tensor, LongTensor) output buffer torch.sort(input, dim=None, descending=False, out=None)-&gt;(Tensor, LongTensor) 对输入张量 input 沿着指定维按升序排序。如果不给定 dim ，则默认为输入的最后一维。如果指定参数 descending 为 True ，则按降序排序 返回tuple(sorted_tensor, sorted_indices) 会改变tensor的函数操作会用一个下划线后缀来标示。比如,torch.FloatTensor.abs_()会在原地计算绝对值，并返回改变后的tensor，而tensor.FloatTensor.abs()将会在一个新的tensor中计算结果。 view()函数作用是将一个多行的Tensor,拼接成一行。 torch.max(x,1 or 0) 返回两个res，第一个是最大值，第二个是对应的索引值；第二个参数 0 代表按列取最大值并返回对应的行索引值，1 代表按行取最大值并返回对应的列索引值。 transpose只能操作2D矩阵的转置。有两种调用方式。连续使用transpose也可实现permute的效果。 torch.index_select(input, dim, index, out=None)-&gt;Tensor w 在指定维度dim方向上从input中抽取由位置序列index所指定的值。output的其他维度的长度和原来矩阵相同，在第dim维度上的长度和index的长度相同。 torch 加法 第一种：a+b 第二种：torch.add(a,b) 第三种：result = torch.Tensor(5,3)torch.add(a,b,out=result) #把运算结果存储在result上 第四种：b.add_(a) #把运算结果覆盖掉b 乘积 Pytorch 的 mm 是矩阵的外积，而dot是元素对应积，即对应位置的元素相乘，需要左右矩阵形状一致。这点和numpy、mxnet不一样。 torch.div(input,value,out=None) -&gt; Tensor #逐元素除 expand(*sizes) -&gt; Tensor expand_as(tensor) == self.expand(tensor.size()) torch.unsqueeze(input, dim=None, out=None) 返回一个新的张量，对输入的制定位置插入维度 1 注意:返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。 将输入张量形状中的1 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)，那么输出形状就为:(A×B×C×D)当给定dim时，那么挤压操作只在给定维度上。例如，输入形状为: (A×1×B), squeeze(input, 0) 将会保持张量不变，只有用 squeeze(input, 1)，形状会变成 (A×B)。 如果dim为负，则将会被转化dim+input.dim()+1 tensor (Tensor) – 输入张量 dim (int) – 插入维度的索引 out (Tensor, optional) – 结果张量]]></content>
  </entry>
  <entry>
    <title><![CDATA[闲杂笔记]]></title>
    <url>%2F2019%2F06%2F08%2Fcppnote%2F</url>
    <content type="text"><![CDATA[Cin.get(),返回一个cin对象，会把换行符留在输入队列，若连续输入，可以：使用cin.get()或者cin.get().get(). Delete [] p; 删除整个动态数组。 大多数情况，把数组名解析成地址。但是在sizeof运算中，并不会这样。sizeof运算在数组上，得到的是数组的长度。 auto关键字只能用于单值初始化推断，不能用于初始化列表。 数据成员被初始化的顺序和他们在类声明中的顺序相同，与初始化器中的顺序无关。 赋值符号进行浅拷贝，指向同一地址，不开辟新的内存空间。深拷贝开辟新的内存空间。 new A和new A() 区别 ,当A是POD时，有区别，且C++98和C++03会有区别。在Apple LLVM version 9.0.0 (clang-900.0.38)没有区别。 POD是Plain old data的缩写，它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。 算数表达式中，同时存在unsigned和int，会把int转化为unsigned。无符号数运算结果如何是有符号数会自动转型无符号。 字符型分为，char， signed char，unsigned char. unsigned和signed混合计算，结果不要出现负数。 C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量. ::全局作用符覆盖默认作用域规则。 void *p 可以指向所有类型，但是不能操作内容。 对于string类的输入函数，它会自动忽略开头的空白（空格、制表符、换行等等），从第一个真正的字符开始直到下一个空白。 对于getline()函数，它会保存字符串中的空白符，它读入数据，直到遇到换行符位置。 size_t类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。是unsigned int。 栈解旋:从进入try块到抛出异常之前，栈中构造的所有对象将被析构，析构顺序和构造顺序相反。 栈上：A a();//这里声明了一个函数，没有传入的参数，返回值为类类型A b;//默认调用“对象名()”这个构造函数构造对象A c(1);//默认调用相应的构造函数构造对象堆上:加括号不加括号一般无差别，都调用默认的构造函数(参考条例7)A *d = new A();A *e = new A;对于内置类型而言:加括号是进行了初始化，不加是未进行初始化int *f = new int();int *g = new int; 未完待续 闲杂笔记]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
</search>
