<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++基础总结]]></title>
    <url>%2F2019%2F07%2F29%2Finterview_one%2F</url>
    <content type="text"><![CDATA[const(不可变)作用1. 修饰常量 2. 修饰指针 指针常量和常量指针 3. 常量引用 避免拷贝，避免对值的修改 4. 修饰成员函数 函数内部不能修改成员函数使用12345678const int a1;int get() const;const char* p1 = a2;//常量指针，指向常量的指针，保护指向的地址空间不可变。指针可变。char* const p2 = a3;//指针常量， 保护指针，指针自身的地址空间不可变，数据可变。//不能把常量的地址赋给指针变量void get(const int val);void get(const int *val);void get(int *const val); static()作用1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前分配空间，如果有初始值就用初始值初始化，如果没有初始值系统用默认值初始化。 2. 修饰普通函数，该函数仅在定义该函数的文件内才能使用。 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，使用类名作用域符号访问，但是在 static 函数内不能访问非静态成员。this指针1. 指向非静态成员的特殊指针。 2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 3. this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值。在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。 4. this 只是一个右值，不能使用&amp;this 5. 在以下场景中，经常需要显式引用 this 指针： 1. 为实现对象的链式引用。 2. 为避免对同一对象进行赋值操作。 3. 在实现一些数据结构时，如 list。inline特征1. 相当于直接执行函数体。 2. 相当于宏操作，但是多了类型检查。 3. 编译器一般不内敛包含循环，递归，switch等复杂操作的inline函数。 4. 在类声明中定义的函数，除了虚函数的其他函数会自动隐式地当成inline函数。使用12345// 类外定义需要显示inlineclass A&#123; void b();&#125;inline void A::b()&#123;&#125;; 编译器对inline函数的处理过程1. 函数体复制到调用点。 2. 为局部变量分配内存空间。 3. 将inline函数中的输入参数和返回值映射到调用方法的局部变量空间。 4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。优劣优点1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 4. 内联函数在运行时可调试，而宏定义不可以。缺点1. 代码膨胀，省去了调用函数的开销。关键在于函数体内执行时间和调用函数开销的平衡。 2. inline函数无法随着函数库升级而升级，inline函数改变需要重新编译，无法直接链接。 3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。tips: virtual可以inline，但是当virtual表示多态性时，不能内联。 inline是编译器建议编译器内联，在程序运行之前，但是多态性的表现在程序运行中。 当编译器明确知道调用对象是哪一个类时，具有实际对象，而不是对象指针或引用，可以使用 inline virtual volatile1volatile int a = 1; 1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 2. volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） 3. const 可以是 volatile （如只读的状态寄存器） 4. 指针可以是 volatile12345678## assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。### 使用```c++# define NDEBUG# cinlude &lt;cassert&gt;assert(p!=NULL); pragma pack(n)强制设定struct,union,class成员变量以n 字节对齐方式。 12#pragma pack(push)#pragma pack(8) 位域1Bit mode:2; 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。 位域内存布局和机器有关 类型必须是整型或者枚举，signed int根据具体实现而定。 取地址和指针不能作用于位域。 extern “C”按照C语言方式编译和链接。extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 1234567#ifdef _cpextern "C"&#123;#endif void *memeset(void *,int ,size_t);#ifdef _cp&#125;#endif structc12345typedef struct a&#123;&#125;s;// 等价于struct a&#123;&#125;;typedef struct a s;// 但两个标识符名称空间不相同。 cpp编译器定位符号的规则改变，首先搜索全局标识符表，如果没有将会搜索类标识符表。 没有同名类 A，可省略struct 12struct A&#123;&#125;;void m(A m); 如果有同名类 A，则A 代表类A，struct A 代表结构体A。 class和struct 本质区别是默认的访问权限，struct默认public,class默认private。 union联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： * 默认权限public * 可以含有析构函数，构造函数 * 不能含有引用类型的成员 * 不能作为derived class，不能作为base class * 不能含有virtual * 匿名union在定义所在的scope可直接访问union member * 匿名union不能包含protected和private member * 全局匿名联合必须是static。explicit 修饰构造函数，防止隐式转换和复制初始化。 修饰转换函数，防止隐式转换，按语境转换除外。123456789101112131415161718192021222324252627282930313233class A&#123; A(int a)&#123;&#125; operator bool() const &#123;return false;&#125;&#125;;class B&#123; B(int b)&#123;&#125; explicit operator bool() const&#123;return false;&#125;&#125;;void getA(A a)&#123;&#125;void getB(B b)&#123;&#125;int main()&#123; A a1(1);//直接初始化 A a2 = 1;//复制初始化 A a3&#123;1&#125;;//直接列表初始化 A a4 = &#123;1&#125;;//复制列表初始化 A a5 = (A)1;//允许static_cast 显示转型 getA(1);//允许int到A的隐式转换 if (a1);//使用转换函数A::operator bool() 的从A到bool的隐式转换 bool a6(a1);//使用转换函数 A::operator bool()的从A到bool的隐式转换 bool a7 = a1;//使用转换函数A::operator bool()的从A到bool的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1);//static_cast 进行直接初始化 B b1(1);//ok B b2 = 1;//false, explitct修饰的构造函数不可复制初始化，不可复制列表初始化 getB(b1);// 被explicit修饰的构造函数的对象不允许你int到B隐式转换 if(b1); bool b6(b1); 被explicit 修饰的转换函数的对象可以按语境转换。 bool b7 = b1; false，被explicit修饰的构造函数的对象不允许B到bool的转型。 bool b8 = static_cast&lt;bool&gt;(b1); return 0;&#125; 引用左值引用常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。引用折叠X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;成员初始化列表有些场合必须要用初始化列表： 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thread]]></title>
    <url>%2F2019%2F07%2F18%2Fthread%2F</url>
    <content type="text"><![CDATA[多进程并发将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。独立的进程可以通过进程间常规的通信渠道传递讯息。 + 缺点 因为OS的保护措施，进程之间的通信通常复杂或者慢。 运行多个进程需要时间启动进程，操作系统需要内部资源来管理进程。 + 优点 OS 在进程间提供附加的保护操作和高级别的通信机制，使得更容易编写安全的并发代码。 可以使用远程连接的方式，在不同的机器上运行独立的进程。多线程并发并发的另一个途径是在单个进程中运行多个线程。线程类似于轻量级的进程。 + 缺点 缺少线程间的数据保护，如果数据要被多个线程访问，我们必须确保每个线程所访问的的数据是一致的，因此需要对线程通信做大量的工作。 + 优点 共享地址空间，缺少数据保护，所以工作量小，多线程开销远小于多进程。C++ 11 std::thread+ C++ 11 引入了&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。+ 声明了 std::atomic和 std::atomic_flag + 生命了一套C风格的原子类型及兼容C的操作函数。+ 声明了 std::thread,std::this_thread+ 声明了相关mutex类。 + std::mutex,std::lock_guard,std::unique_lock.+ 相关condition_variable 类， std::condition_variable和std::condition_variable_any+ std::promise,std::package_task.std 线程类+ std::thread 类的构造函数使用可变参数模板。 1template&lt;typename _Callable, typename... _Args&gt; 1. 函数指针 2. 重载运算符的类对象,仿函数 3. lambda表达式 4. std::function函数指针1234567891011void func1()&#123;&#125;void func2(int i)&#123;&#125;void func3(int i,std::string m)&#123;&#125;std::thread t1(func1);std::thread t2(func2,1);std::thread t3(func3,1,"abc");t1.join();t2.join();t3.join(); 仿函数123456789101112class Fctor &#123;public: // 具有一个参数 void operator() () &#123; &#125;&#125;;Fctor f;std::thread t1(f); std::thread t2(Fctor()); // falsestd::thread t3((Fctor())); // okstd::thread t4&#123;Fctor()&#125;; // ok 一个仿函数类生成的对象，使用起来就像一个函数一样. t2错误，编译器把Fctor()解释为函数声明，并非是临时对象。 在参数添加小括号，进行调用。 使用{}进行构造。 lambda 函数123456std::thread t1([]()&#123; std::cout&lt;&lt;"lambda"&lt;&lt;std::endl;&#125;);//无参std::thread t2([](std::int m)&#123; std::cout&lt;&lt;"lambda"&lt;&lt;m&lt;&lt;std::endl;&#125;,1);//有参 std::fucntion1234567891011121314151617181920212223class A&#123;public: void func1()&#123; &#125; void func2(int i)&#123; &#125; void func3(int i, int j)&#123; &#125;&#125;;A a;std::function&lt;void(void)&gt; f1 = std::bind(&amp;A::func1, &amp;a);std::function&lt;void(void)&gt; f2 = std::bind(&amp;A::func2, &amp;a, 1);std::function&lt;void(int)&gt; f3 = std::bind(&amp;A::func2, &amp;a, std::placeholders::_1);std::function&lt;void(int)&gt; f4 = std::bind(&amp;A::func3, &amp;a, 1, std::placeholders::_1);std::function&lt;void(int, int)&gt; f5 = std::bind(&amp;A::func3, &amp;a, std::placeholders::_1, std::placeholders::_2);std::thread t1(f1);std::thread t2(f2);std::thread t3(f3, 1);std::thread t4(f4, 1);std::thread t5(f5, 1, 2); 构造函数的第一个参数是可调用对象，默认情况下传递的是一个副本。当使用构造函数创建对象的时候，是将参数先赋值给这些变量，所以这些变量只是个副本，然后在线程启动并调用线程入口函数时，传递的参数只是这些副本。 线程对象只能移动不可复制将线程的所有权在std::thread实例间进行转移。1234void f1();void f2();std::thread t1(f1);std::thread t2 = std::move(t1);]]></content>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exception]]></title>
    <url>%2F2019%2F07%2F18%2Fexception%2F</url>
    <content type="text"><![CDATA[中定义了一系列标准的异常。 std::exceptionstd::bad_alloc 该异常可以通过 new 抛出。std::bad_cast 该异常通过dynamic_cast抛出。std::bad_exception std::bad_typeid 该异常可以通过 typeid 抛出。std::logic_error 理论上可以通过读取代码来检测到的异常。std::domain_error 当使用了一个无效的数学域时，会抛出该异常。std::invalid_argument 当使用了无效的参数时，会抛出该异常。std::length_error 当创建了太长的 std::string 时，会抛出该异常。std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。std::runtime_error 理论上不可以通过读取代码来检测到的异常。std::overflow_error 当发生数学上溢时，会抛出该异常。std::range_error 当尝试存储超出范围的值时，会抛出该异常。std::underflow_error 当发生数学下溢时，会抛出该异常。]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memo]]></title>
    <url>%2F2019%2F07%2F15%2Fmemo%2F</url>
    <content type="text"><![CDATA[方法一：暴力法123456789int climb(int i,int n)&#123;if(i&gt;n) return 0;if(i ==n) return 1;return climb(i+1,n)+climb(i+2,n);&#125;int climbs(int n)&#123; return climb(0,n);&#125; 时间复杂度：O(2n)O(2^n)O(2n)。树形递归的大小为 2n2^n2n . 空间复杂度：O(n)。递归树的深度可以达到 nn 方法 2：记忆化递归12345678910111213class Solution&#123; public: climbs(int n)&#123; vector&lt;int&gt; memo; return climbs(0,n,memo); &#125; int climb_memo(int i,int n,vector&lt;int&gt; memo)&#123; if(i&gt;n) return 0; if(i ==n) return 1; if(memo[i]&gt;0) return memo[i]; return climb_memo(i+1,n,memo)+climb_memo(i+2,n,memo); &#125;&#125; 时间复杂度：O(n) 。树形递归的大小可以达到 n. 空间复杂度：O(n) 。递归树的深度可以达到 n. 方法 3：动态规划12345678910111213class Solution&#123; public: climbs(int n)&#123; if(n==1) return 1; &#125; vector&lt;int&gt; dp; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++)&#123; dp[i] = dp[i-1] + dp[i-2] &#125; return dp[n];&#125; 时间复杂度：O(n)，单循环到 n 。 空间复杂度：O(n), dp 数组用了 n 的空间]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 导入conda环境]]></title>
    <url>%2F2019%2F07%2F10%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebook导入conda环境 不使用ipykernel，采用nb_condaconda install nb_conda 注意安装的时候不要激活环境 可以直接在jupyter里面安装包 可以在ipynb里面更改环境]]></content>
      <tags>
        <tag>conda,jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch]]></title>
    <url>%2F2019%2F07%2F02%2Fpytorch%2F</url>
    <content type="text"><![CDATA[torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor) 沿给定dim维度返回输入张量input中 k 个最大值。 如果不指定dim，则默认为input的最后一维。 如果为largest为 False ，则返回最小的 k 个 值。 返回一个元组 (values,indices)，其中indices是原始输入张量input中测元素下标。如果设定布尔值sorted 为_True_，将会确保返回的k 个值被排序。 input (Tensor) – 输入张量 k (int) – “top-k”中的k dim(int, optional) – 排序的维 largest(bool, optional) – 布尔值，控制返回最大或最小值 sorted(bool, optional) – 布尔值，控制返回值是否排序 out(tuple, optional)–可选输出张量 (Tensor, LongTensor) output buffer torch.sort(input, dim=None, descending=False, out=None)-&gt;(Tensor, LongTensor) 对输入张量 input 沿着指定维按升序排序。如果不给定 dim ，则默认为输入的最后一维。如果指定参数 descending 为 True ，则按降序排序 返回tuple(sorted_tensor, sorted_indices) 会改变tensor的函数操作会用一个下划线后缀来标示。比如,torch.FloatTensor.abs_()会在原地计算绝对值，并返回改变后的tensor，而tensor.FloatTensor.abs()将会在一个新的tensor中计算结果。 view()函数作用是将一个多行的Tensor,拼接成一行。 torch.max(x,1 or 0) 返回两个res，第一个是最大值，第二个是对应的索引值；第二个参数 0 代表按列取最大值并返回对应的行索引值，1 代表按行取最大值并返回对应的列索引值。 transpose只能操作2D矩阵的转置。有两种调用方式。连续使用transpose也可实现permute的效果。 torch.index_select(input, dim, index, out=None)-&gt;Tensor w 在指定维度dim方向上从input中抽取由位置序列index所指定的值。output的其他维度的长度和原来矩阵相同，在第dim维度上的长度和index的长度相同。 torch 加法 第一种：a+b 第二种：torch.add(a,b) 第三种：result = torch.Tensor(5,3)torch.add(a,b,out=result) #把运算结果存储在result上 第四种：b.add_(a) #把运算结果覆盖掉b 乘积 Pytorch 的 mm 是矩阵的外积，而dot是元素对应积，即对应位置的元素相乘，需要左右矩阵形状一致。这点和numpy、mxnet不一样。 torch.div(input,value,out=None) -&gt; Tensor #逐元素除 expand(*sizes) -&gt; Tensor expand_as(tensor) == self.expand(tensor.size()) torch.unsqueeze(input, dim=None, out=None) 返回一个新的张量，对输入的制定位置插入维度 1 注意:返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。 将输入张量形状中的1 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)，那么输出形状就为:(A×B×C×D)当给定dim时，那么挤压操作只在给定维度上。例如，输入形状为: (A×1×B), squeeze(input, 0) 将会保持张量不变，只有用 squeeze(input, 1)，形状会变成 (A×B)。 如果dim为负，则将会被转化dim+input.dim()+1 tensor (Tensor) – 输入张量 dim (int) – 插入维度的索引 out (Tensor, optional) – 结果张量]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ptroch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲杂笔记]]></title>
    <url>%2F2019%2F06%2F08%2Fcppnote%2F</url>
    <content type="text"><![CDATA[Cin.get(),返回一个cin对象，会把换行符留在输入队列，若连续输入，可以：使用cin.get()或者cin.get().get(). Delete [] p; 删除整个动态数组。 大多数情况，把数组名解析成地址。但是在sizeof运算中，并不会这样。sizeof运算在数组上，得到的是数组的长度。 auto关键字只能用于单值初始化推断，不能用于初始化列表。 数据成员被初始化的顺序和他们在类声明中的顺序相同，与初始化器中的顺序无关。 赋值符号进行浅拷贝，指向同一地址，不开辟新的内存空间。深拷贝开辟新的内存空间。 new A和new A() 区别 ,当A是POD时，有区别，且C++98和C++03会有区别。在Apple LLVM version 9.0.0 (clang-900.0.38)没有区别。 POD是Plain old data的缩写，它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。 算数表达式中，同时存在unsigned和int，会把int转化为unsigned。无符号数运算结果如何是有符号数会自动转型无符号。 字符型分为，char， signed char，unsigned char. unsigned和signed混合计算，结果不要出现负数。 C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量. ::全局作用符覆盖默认作用域规则。 void *p 可以指向所有类型，但是不能操作内容。 对于string类的输入函数，它会自动忽略开头的空白（空格、制表符、换行等等），从第一个真正的字符开始直到下一个空白。 对于getline()函数，它会保存字符串中的空白符，它读入数据，直到遇到换行符位置。 size_t类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。是unsigned int。 栈解旋:从进入try块到抛出异常之前，栈中构造的所有对象将被析构，析构顺序和构造顺序相反。 栈上：A a();//这里声明了一个函数，没有传入的参数，返回值为类类型A b;//默认调用“对象名()”这个构造函数构造对象A c(1);//默认调用相应的构造函数构造对象堆上:加括号不加括号一般无差别，都调用默认的构造函数(参考条例7) 12 A *d = new A();A *e = new A; 对于内置类型而言:加括号是进行了初始化，不加是未进行初始化 12int *f = new int();int *g = new int; 未完待续 闲杂笔记]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
