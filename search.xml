<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2Funcategorized%2Foperatoration%2F</url>
    <content type="text"><![CDATA[概要基本特征 共享-互斥共享和同时共享 并发与并行 虚拟-时（时间）分复用技术和空（空间）分复用技术 异步基本功能进程管理进程与线程 进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 线程是独立调度的基本单位。 区别： 线程不占有资源 同一进程中的线程切换不会导致进程切换 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。切换就绪态，运行态，阻塞态进程调度算法批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 先来先服务 first-come first-serverd（FCFS） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 交互式系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系。 优先度调度 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同。进程在第一个队列没执行完，就会被移到下一个队列。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以看成是时间片轮转调度算法和优先级调度算法的结合。 实时系统实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 同步互斥 对临界资源进行访问的那段代码称为临界区。 管程 同步互斥进程通信管道管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。unistd.hint pipe(int fd[2]); 半双工通信。 只能在父子进程和兄弟进程中使用。FIFO命名管道，去除了管道只能在父子进程中使用的限制123#include &lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 消息队列 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难。 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法。 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。信号量共享存储套接字共享存储死锁必要条件 资源互斥 占有和等待 不可抢占 死循环处理方法鸵鸟策略死锁检测不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 每种类型一个资源的死锁检测 从一个节点开始深度优先遍历，查找是否存在有向环。 每种类型多个资源的死锁检测上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 递归，直到所有进程均被访问，若存在未被访问进程，则产生死锁。 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复死锁预防破坏4个必要条件 要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。 要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。 资源编号，顺序请求。死锁避免 进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配 银行家算法 安全状态 即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。银行家算法 单个资源的银行家算法 多资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。算法：按照分配矩阵进行分配，寻找小于等于可用资源的行，如果不存在则状态不安全。存在则释放该行继续迭代。状态不安全。 内存管理文件管理设备管理磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 FCFS frist come frist served SSTF shortest seek time frist 优先调度与当前磁头所在磁道距离最近的磁道。容易产生饥饿现象。远端请求长时间无法响应。 SCAN 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。单向访问距离最近的磁道。直到该方向上没有未完成的磁盘请求，然后改变方向。 CSCAN 保持最大磁道挨着最小磁道和SCAN相似，但是到达内部之后立即调整到最外层，继续往内。或者相反。 系统调用Linux 系统调用|task|command|| —- | —-||进程控制|fork();exit();wait()||进程通信| pipe(); shmget(); mmap()||文件操作| open(); read();write()||设备操作| ioctl();read();write()||信息维护| getpid(); alarm(); sleep()||安全| chmod();umask();chown()| 内核大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断外中断由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。异常由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。陷入用户系统调用链接装载 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。静态链接 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 在可执行文件中产生一份拷贝。目标文件 可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 动态链接在内存中一般只保留该编译单元的一份拷贝。 装载时动态链接(Load-time Dynamic Linking)：这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，调用函数的时候利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中(全部函数加载进内存），其主要目的是便于代码共享。（动态加载程序，处在加载阶段，主要为了共享代码，共享代码内存） 运行时动态链接(Run-time Dynamic Linking)：这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，将其加载到内存中（只加载调用的函数进内存），并标识内存地址，其他程序也可以使用该程序，并用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址。（dll在内存中只存在一份，处在运行阶段）]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2Funcategorized%2Fsql%2F</url>
    <content type="text"><![CDATA[SELECT col,col,col 找什么？FROM table 从哪找？WHERE col 条件 条件是啥？ 条件：数字(where)当查找条件col是数字 select * from table where col = 1; Operator Condition SQL Example 解释 , !=, &lt; &lt;=, &gt;, &gt;= Standard numerical operators col != 4 等于 大于 小于 BETWEEN … AND … Number is within range of two values (inclusive) col BETWEEN 1.5 AND 10.5 在 X 和 X之间 NOT BETWEEN … AND … Number is not within range of two values (inclusive) co NOT BETWEEN 1 AND10 不在 X 和 X之间 IN (…) Number exists in a list col IN (2, 4, 6) 在 X 集合 NOT IN (…) Number does not exist in a list col NOT IN (1, 3, 5) 不在 X 集合 ## 条件：文本(where) 当查找条件col是文本 select * from table where col like ‘%jin’; Operator Condition SQL Example 解释 = Case sensitive exact string comparison (notice the single equals) col = “abc” 等于 != or &lt;&gt; Case sensitive exact string inequality comparison col != “abcd” 不等于 LIKE Case insensitive exact string comparison col LIKE “ABC” 等于 NOT LIKE Case insensitive exact string inequality comparison col NOT LIKE “ABCD” 不等于 % Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) col LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) 模糊匹配 _ Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) col LIKE “AN_” (matches “AND”, but not “AN”) 模糊匹配单字符 IN (…) String exists in a list col IN (“A”, “B”, “C”) 在集合 NOT IN (…) String does not exist in a list co NOT IN (“D”, “E”, “F”) 不在集合 ## 排序(rows) 需要对结果rows排序和筛选部分rows select * from table where col &gt; 1 order by col asc limit 2 offset 2 Operator Condition SQL Example 解释 ORDER BY . ORDER BY col ASC/DESC 按col排序 ASC . ORDER BY col ASC/DESC 升序 DESC . ORDER BY col ASC/DESC 降序 LIMIT OFFSET . LIMIT num_limit OFFSET ORDER BY . ORDER BY col1 ASC,col2 DESC 多列排序 ## join:连表(table) 当查找的数据在多张关联table里 select * from table1 left join table2 on table1.id = table2.id where col &gt; 1 Operator Condition SQL Example 解释 JOIN .. ON .. . t1 JOIN t2 ON t1.id = t2.id 按ID连成1个表 INNER JOIN . t1 INNER JOIN t2 ON t1.id = t2.id 只保留id相等的row LEFT JOIN . t1 LEFT JOIN t2 ON t1.id = t2.id 保留t1的所有row RIGHT JOIN . t1 RIGHT JOIN t2 ON t1.id = t2.id 保留t2的所有row IS/IS NOT NULL . col IS/IS NOT NULL col是不是为null ## 算式(select / where) 当需要对select的col 或 where条件的col 经过一定计算后才能使用 select ,col2 from table where col/2 &gt; 1 Operator Condition SQL Example 解释 + - * / % . col1 + col2 col加减乘除 substr . substr(col,0,4) 字符串截取 AS . col * 2 AS col_new col取别名 ## 统计（select） 对查找的rows需要按col分组统计的情况 select count(*),avg(col),col from table where col &gt; 1 group by col Operator Condition SQL Example 解释 COUNT(*), COUNT(column) A common function used to counts the number of rows in the group if no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column. count(col) 计数 MIN(column) Finds the smallest numerical value in the specified column for all rows in the group. min(col) 最小 MAX(column) Finds the largest numerical value in the specified column for all rows in the group. max(col) 最大 AVG(column) Finds the average numerical value in the specified column for all rows in the group. avg(col) 平均 SUM(column) Finds the sum of all numerical values in the specified column for the rows in the group. sum(col) 求和 GROUP BY . group by col,col2 分组 HAVING . HAVING col&gt;100 分组后条件 子表 (table)一次select的结果rows作为下一次select的临时table才能得到最终结果 select * from (select * from table where col &gt; 1) as tmp where col &lt; 1 Operator Condition SQL Example 解释 （select -）as tmp （select -）as tmp select结果做子表 in（select -） in（select -） select结果做条件 avg（select -） avg（select -） select结果做条件]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++2.0]]></title>
    <url>%2Funcategorized%2FCpp11%2F</url>
    <content type="text"><![CDATA[auto auto不能用来声明函数的返回值。但是如果函数有一个尾随的返回类型，auto是可以声明返回值。1234template&lt;class T1, class T2&gt;auto test(T1 t1,T2 t2) -&gt; **decltype**(t1 + t2)&#123; return t1+t2;&#125; std::array array对象的长度是固定的，使用了静态存储区，即存储在栈上，效率跟数组相同，但是更加的安全。 nullptr nullptr-&gt;void* nullptr是std::nullptr_t。存在和任何指针类型以及类成员指针类型的空值，bool类型的隐式转换。 不存在整型的隐式转换。12345678910f(int *p)&#123;&#125;f1(bool o)&#123;&#125;f2(std::share_ptr&lt;int&gt; p)&#123;&#125; int p1 = NULL;int p2 = nullptr;if(p1==p2);f(p2);f1(p2);f2(p2);int i = nullptr; //false 基于范围的for循环12345678910111213for ( val declare : collection ) statementfor(int e : arr)&#123; e = e*e; std::cout&lt;&lt;e&lt;&lt;std::endl;&#125;template&lt;class InputIterator, class Function&gt; Function for_each( InputIterator _First, InputIterator _Last, Function _Func ); override final override:表示函数应当重写基类中的虚函数。（纯虚函数，抽象类） final:表示派生类不应当重写这个虚函数。123456789101112131415161718class A&#123; public: virtual void func(int i)&#123; cout&lt;&lt;"A::f"&lt;&lt;endl; &#125;&#125;;class B : public A&#123; public: virtual void func(long l) final &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;;class C : public A&#123; public: virtual void func(int i) override &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;; 强类型枚举 传统enum会将常量暴露在外层作用域。存在隐式整型转型。 强类型枚举由关键字enum class标识，不存在隐式转整型。12enum class a&#123;one,two,all&#125;;a ob = a::one; variadic templates 可变参数列表, 类型和个数任意1234567891011template &lt;class T, class... Args&gt;void print(const T &amp;first, const Args &amp;... args)&#123; cout&lt;&lt;first&lt;&lt;endl; print(args...);&#125;void print()&#123;&#125;template&lt; class...T&gt;void print(const Args &amp;... args)&#123; /**/&#125; 智能指针 pointer-like classess#include&lt;memoray&gt; 智能指针构造函数是explicit,拒绝内置指针隐式转换为智能指针。 shared_ptr&lt;T&gt; 可以指向同一地址空间，通过count计数，防止成为空悬指针。 unique_ptr&lt;T&gt; 独占内存空间。 不要使用get()初始化指针，会产生未定义行为。 常用共有函数列表 p.get() 返回内置指针。 swap(a,b) a.swap() 交换指针 shared_ptr&lt;T&gt; p 独有函数 make_shared&lt;T&gt;(arg) 返回一个指针 指向用arg初始化的对象。 shared_ptr&lt;T&gt; p(q) 拷贝构造函数赋值。 p.unique()-&gt;bool p.use_count()-&gt;int 123456shared_ptr&lt;double&gt;pd;double *p_reg = new double;pd = p_reg;//错误，不允许隐式转换pd = shared_ptr&lt;double&gt;(p_reg);//正确shared_ptr&lt;double&gt; pshared = p_reg;//错误，不允许隐式转换shared_ptr&lt;double&gt; pshared(p_reg);//正确 不能将smart point 应用非堆内存. auto_ptr&lt;T&gt; p(new T); 旧版本的auto_ptr，尽量用新智能指针替代。unique_ptr&lt;T&gt; p(new T); unique_ptr&lt;T&gt; 拒绝拷贝和赋值。但可以通过u.reset() .u.release()间接拷贝和赋值。 release()-&gt;pointer u.reset(m) 提供可选指针参数列表，u = m 12345678910template &lt; class T&gt;class shared_ptr&#123; private: T *p; public: shared_ptr(T *pm):p(pm)&#123;&#125; T&amp; operator*() const&#123;return *p;&#125; T* operator-&gt;() const&#123;return p;&#125;&#125;;//-&gt;运算符作用之后得到的输出继续用-&gt;作用。 迭代器 pointer-like classes12345678910111213141516171819template&lt; class T&gt;struct __list_node&#123; void *prev; void *next; T data;&#125;;template&lt; class T,class Ref, class Ptr&gt;class __list_iterator&#123; typedef __list_iterator&lt;T,Ref,Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; link_type node; bool operator==(const self&amp;x)const&#123; return node == x.node; &#125; reference operator*() const &#123;return (*node).data;&#125; pointer operator-&gt;() const &#123;return &amp;(operator*());&#125;&#125; std::bind 将函数、成员函数和闭包转成function函数对象 将多元(n&gt;1)函数转成一元函数或者(n-1)元函数。 123456789101112template&lt; class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );template&lt; class R, class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args ); auto x1 = bind(f,10,20,10); auto x2 = bind(f,std::placeholders::_1,2,3); auto x3 = bind(f,std::placeholders::_1,23,std::placeholders::_2); auto x4 = bind&lt;double&gt;(f,std::placeholders::_1,std::placeholders::_2,5); cout&lt;&lt;x1()&lt;&lt;endl; cout&lt;&lt;x2(1)&lt;&lt;endl; cout&lt;&lt;x3(20,32)&lt;&lt;endl; cout&lt;&lt;x4(23,12)&lt;&lt;endl; 某些无法拷贝的参数，只能使用引用传递，需要使用ref 1for_each(words.begin(),words.end,bind(print,ref(os),_1,' ')); bind 无法绑定重载函数,因为重载函数参数个数不同。 bind 绑定成员函数，需要类的实例作为第二个参数。 bind 绑定成员函数，不需要类实例。 123A a();auto m = bind(&amp;A::f(),a);m(); 未完待续 –…-….-…- -.-..—–.—- -…….——.- -.-.-…..-…- -.——……. -..—……… -..—…-.-.-. -..—.-.—.-. ——–….–.. —-.—……. -.-..–.-.-.-.- ——–….–.. ——.-.-.—- —–..-.—..- –……….-. —-..-.-.—.- -……—-.-.-. -.—.—–…- —.-.-…—– –..-.—-..-.- -.——–.-.– -..—..-.-…. –……….-.]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>c++</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据结构整理]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fdatastructure%2F</url>
    <content type="text"><![CDATA[顺序结构顺序栈12345678910111213template &lt;class T&gt;class sq_stack&#123;private: T val; int top; int size;public: sq_stack(); ~sq_stack(); T pop(); void insert(T val); int get_size(sq_stack s);&#125; 队列1234567891011121314template&lt;class T&gt;class sq_queue&#123;private: T val; int front; int rear; int maxsize;public: sq_queue(); ~sq_queue(); int get_rear(sq_queue r); int get_front(sq_queue f); void insert(T val);&#125; 顺序表123456template &lt;class T&gt;class sq_list&#123; vector&lt;T&gt; a; int length; int size;&#125; 链式结构## 12345678910111213template &lt;class T&gt;class link_node&#123;private: T data; link_node *next;public: link_node(T d):data(d),next(nullptr)&#123;&#125; ~link_node();&#125;typedef struct Lnode&#123; elemtype data; struct Lnode *next;&#125;Lnode,*LinkList; 哈希表 哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突解决方法链地址法：key相同用单链表链接开放定址法： 线性探测法：放到key的下一个位置，Hi = (H(key) + i) % m 二次探测法：Hi = (H(key) + i) % m 随机探测法：Hi= (H(key) + 伪随机数) % m 123456789101112typedef char KeyType;typedef struct&#123; KeyType key;&#125;RcdType;typedef struct&#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 🌲二叉🌲存储结构 顺序存储 链式存储遍历方式 先序 后序 中序 层次实现1234567891011121314template &lt;class T&gt;class binary_node&#123;private: binary_node *left; binary_node *right; T val;public: binary_node(int x):val(x),left(nullptr),right(nullptr)&#123;&#125; ~binary_node(); void in_order(binary_node *root); void pre_order(binary_node *root); void post_order(binary_node *root); void level_order(binary_node *root);&#125; 类型 满二叉🌲 完全二叉🌲(堆) 大根堆 小根堆 二叉查找🌲(排序🌲) 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找的最大次数等于数的高度。缺点(多次插入偏向一边的数据，会导致🌲严重不平衡) 平衡二叉🌲(AVL) 平衡因子BF 左高-右高 ,根节点BF&gt;1 右旋 顺时针 &lt;-1 左旋 插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作 最小失衡🌲(平衡二叉树插入新的节点导致失衡的子🌲):调整策略 LL 左孩子右旋 RR 右孩子左旋 LR 左孩子左旋，再右旋 RL 右孩子的左子🌲先右旋，在左旋红黑🌲解决了二叉查找树的不平衡问题。最大查找次数不会超过最短路径的两倍。 节点是红色或黑色。 根节点为黑色。 所有的叶子节点都是黑色的空节点。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。自平衡 变色 旋转 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum tree_color(RED,BLACK);template &lt;class T&gt;class rb_node&#123;public: tree_color color; T key; rb_node *left; rb_node *right; rb_node *parent; rb_node(T val,rb_color c,rb_node l,rb_node r,rb_node p):key(val),color(c),left(l),right(r),parent(p)&#123;&#125;&#125;;template &lt;class T&gt;class rb_tree&#123; rb_tree(); ~rb_tree(); void pre_order(); void in_order(); void post_order(); rb_node&lt;T&gt;* re_search(T key); //递归查找 rb_node&lt;T&gt;* iter_serach(T key); //非递归 T minkey(); T maxkey(); rb_node&lt;T&gt;* successor(rb_node&lt;T&gt; *x); rb_node&lt;T&gt;* predecessor(rb_node&lt;T&gt; *x); void insert(T key); void remove(T key); void destory(); void print();private: void left_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x); void right_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x);&#125;## B🌲* m阶B🌲 1. 每个结点最多有m-1个关键字 2. 根结点最少可以只有1个关键字 3. 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它 4. 根结点到每个叶子结点高度相同 5. 非根结点至少有Math.ceil(m/2)-1个关键字### 实现```c++template &lt;class T&gt;struct B_tree_node &#123; int n; T *key; bool is_leaf; struct B_tree_node *parent; struct B_tree_node **child;&#125;;template &lt;class T&gt;class B_tree&#123;private: B_tree_node&lt;T&gt;* root; int m;public: B_tree(int tVal = 2); ~B_tree(); B_tree_node&lt;T&gt;* search_tree(B_tree_node&lt;T&gt;* root, T k ,int &amp;index); B_tree_node&lt;T&gt;* getRoot(); void insert(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); void delete(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); T get_value(B_tree_node&lt;T&gt;* root,T value);&#125;; B+ M阶B+🌲 内结点存有关键字和指向孩子结点指针。外结点存有关键字和数据。 叶子结点还有关键字，按照关键字大小排序，叶子结点中存在指向兄弟结点的指针。 一颗B+🌲存在两个指针，一个指向根结点，一个指向存有最小关键字的结点。 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引。 123456789101112template &lt;class T&gt;class bp_node&#123; public: bp_node(); virtual ~bp_node(); private: T data;&#125;;template &lt;class T&gt;class inter_node: public bp_node&#123; public:&#125; 八叉树图排序查找递归折半查找归并查找快速排序迭代折半查找归并查找]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>未完待续</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础总结2]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_two%2F</url>
    <content type="text"><![CDATA[OOP 多态 C++多态分类及其实现 重载多态(Ad-hoc Polymorphism,编译期) 函数重载，运算符重载 子类型多态(Subtype Polymorphism,运行期) 虚函数 参数多态性(Parametric PolyMorphism) 编译期 类模板，函数模板 强制多态(Coerion PolyMorphism 编译期,运行期) 类型转换 静态多态（编译期间，早绑定） 函数重载,模板 动态多态（运行期间，晚绑定） 虚函数 tips: 普通函数不可是virtual static 不可为virtual 构造函数不可为virtual,因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针 virtual ~作用 * 解决based point-&gt; derived object,用based point 删除derived object.虚函数指针，虚函数表虚继承虚继承用于解决多继承条件下的菱形继承问题浪(费存储空间、存在二义性) * 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4字节）和虚基类表(不占用类对象的存储空间)(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了);当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 * 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。虚函数和虚继承 都使用了虚指针(占用类的存储空间)和虚表（不占类存储空间） 虚函数表存储的是虚函数地址，虚基类表存储相对直接继承类的位偏移。 虚基类在子类中存在一份拷贝，而虚函数不占用存储空间。 tips: 模板类可以使用虚函数。 但任何类的成员模板函数不能是虚函数。 聚合类用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配管理 malloc 申请指定字节内存，初始值不确定。 char *str = (char*) malloc(100); calloc 为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc 更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca 在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 new/new[]先底层调用malloc，然后调用构造函数。 delete/delete[]先调用析构函数，然后free，指针置为空。 new能自动计算所需字节数，无需像malloc一样手动操作。 pacement new允许传递额外的地址参数，预先在指定的内存区域创建对象。 123456new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list&#125;//place_address 为 point//initializers可能为空的初始化列表 tips: delete this 合法前提 之后不再调用this指针(任何调用) this对象由new而不是其他任何方式分配的。 该成员函数是this对象最后调用的的成员函数。 剩下的成员函数（delete this之后的)不接触到this对象,包括调用任何其他成员函数或访问任何数据成员。 只在堆上生成对象的类方法：将虚构函数私有。 (C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。) 只在栈上生成对象的类方法：将new和delete操作符重载为私有。 ：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础总结1]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_one%2F</url>
    <content type="text"><![CDATA[const(不可变)作用1. 修饰常量 2. 修饰指针 指针常量和常量指针 3. 常量引用 避免拷贝，避免对值的修改，不能使用非const引用指向const对象。 4. 修饰成员函数 函数内部不能修改成员函数使用123456789101112131415161718192021const int a1;int get() const;const char* p1 = a2;//常量指针，指向常量的指针，保护指向的地址空间数据不可变。指针可变，可以修改const指针所指向的值的，但是不能通过const对象指针来进行，自以为指向const的指针。char* p = a2;*p = a3;char* const p2 = a3;//指针常量， 保护指针，指针自身的地址空间不可变，数据可变。//不能把常量的地址赋给指针变量void get(const int val);void get(const int *val);void get(int *const val);//file1.cppint cout;const int cout2;extern const int cout3;//file2.cppextern int cout; //在全局作用域里定义非const变量时，它在整个程序中都可以访问cout++;cout2; //error除非特别说明，在全局作用域声明的const变量是定义该对象的文件的局部变量，只存在于那个文件，不能被其他文件访问。extern const int cout3;cout3++; static()作用1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前分配空间，如果有初始值就用初始值初始化，如果没有初始值系统用默认值初始化。 2. 修饰普通函数，该函数仅在定义该函数的文件内才能使用。 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，使用类名作用域符号访问，但是在 static 函数内不能访问非静态成员。this指针1. 指向非静态成员的特殊指针。 2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 3. this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值。在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。 4. this 只是一个右值，不能使用&amp;this 5. 在以下场景中，经常需要显式引用 this 指针： 1. 为实现对象的链式引用。 2. 为避免对同一对象进行赋值操作。 3. 在实现一些数据结构时，如 list。inline特征1. 相当于直接执行函数体。 2. 相当于宏操作，但是多了类型检查。 3. 编译器一般不内敛包含循环，递归，switch等复杂操作的inline函数。 4. 在类声明中定义的函数，除了虚函数的其他函数会自动隐式地当成inline函数。使用12345// 类外定义需要显示inlineclass A&#123; void b();&#125;inline void A::b()&#123;&#125;; 编译器对inline函数的处理过程1. 函数体复制到调用点。 2. 为局部变量分配内存空间。 3. 将inline函数中的输入参数和返回值映射到调用方法的局部变量空间。 4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。优劣优点1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 4. 内联函数在运行时可调试，而宏定义不可以。缺点1. 代码膨胀，省去了调用函数的开销。关键在于函数体内执行时间和调用函数开销的平衡。 2. inline函数无法随着函数库升级而升级，inline函数改变需要重新编译，无法直接链接。 3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。tips: virtual可以inline，但是当virtual表示多态性时，不能内联。 inline是编译器建议编译器内联，在程序运行之前，但是多态性的表现在程序运行中。 当编译器明确知道调用对象是哪一个类时，具有实际对象，而不是对象指针或引用，可以使用 inline virtual volatile1volatile int a = 1; 1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 2. volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） 3. const 可以是 volatile （如只读的状态寄存器） 4. 指针可以是 volatile12345678## assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。### 使用```c++# define NDEBUG# cinlude &lt;cassert&gt;assert(p!=NULL); pragma pack(n)强制设定struct,union,class成员变量以n 字节对齐方式。 12#pragma pack(push)#pragma pack(8) 位域1Bit mode:2; 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。 位域内存布局和机器有关 类型必须是整型或者枚举，signed int根据具体实现而定。 取地址和指针不能作用于位域。 extern “C”按照C语言方式编译和链接。extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 1234567#ifdef _cpextern "C"&#123;#endif void *memeset(void *,int ,size_t);#ifdef _cp&#125;#endif structc12345typedef struct a&#123;&#125;s;// 等价于struct a&#123;&#125;;typedef struct a s;// 但两个标识符名称空间不相同。 cpp编译器定位符号的规则改变，首先搜索全局标识符表，如果没有将会搜索类标识符表。 没有同名类 A，可省略struct 12struct A&#123;&#125;;void m(A m); 如果有同名类 A，则A 代表类A，struct A 代表结构体A。 class和struct 本质区别是默认的访问权限，struct默认public,class默认private。 union联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： * 默认权限public * 可以含有析构函数，构造函数 * 不能含有引用类型的成员 * 不能作为derived class，不能作为base class * 不能含有virtual * 匿名union在定义所在的scope可直接访问union member * 匿名union不能包含protected和private member * 全局匿名联合必须是static。explicit 修饰构造函数，防止隐式转换和复制初始化。 修饰转换函数，防止隐式转换，按语境转换除外。 按语境转换 if、while、for 的控制表达式； 内建逻辑运算符 !、&amp;&amp; 和 || 的操作数； 条件运算符 ?: 的首个操作数； static_assert 声明中的谓词； noexcept 说明符中的表达式；12345678910111213141516171819202122232425262728293031class A&#123; A(int a)&#123;&#125; operator bool() const &#123;return false;&#125;&#125;;class B&#123; B(int b)&#123;&#125; explicit operator bool() const&#123;return false;&#125;&#125;;void getA(A a)&#123;&#125;void getB(B b)&#123;&#125;int main()&#123; A a1(1);//直接初始化 A a2 = 1;//复制初始化 A a3&#123;1&#125;;//直接列表初始化 A a4 = &#123;1&#125;;//复制列表初始化 A a5 = (A)1;//允许static_cast 显示转型 getA(1);//允许int到A的隐式转换 if (a1);//使用转换函数A::operator bool() 的从A到bool的隐式转换 bool a6(a1);//使用转换函数 A::operator bool()的从A到bool的隐式转换 bool a7 = a1;//使用转换函数A::operator bool()的从A到bool的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1);//static_cast 进行直接初始化 B b1(1);//ok B b2 = 1;//false, explitct修饰的构造函数不可复制初始化，不可复制列表初始化 getB(b1);// 被explicit修饰的构造函数的对象不允许你int到B隐式转换 if(b1); bool b6(b1); //被explicit 修饰的转换函数的对象可以按语境转换。 bool b7 = b1; false，被explicit修饰的构造函数的对象不允许B到bool的转型。 bool b8 = static_cast&lt;bool&gt;(b1); return 0;&#125; 引用1) 左值引用声明符：声明 S&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的左值引用。 2) 右值引用声明符：声明 S&amp;&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的右值引用。 * 不存在 void 的引用，也不存在引用的引用,引用的数组,指向引用的指针. * 引用坍缩：容许通过模板或 typedef 中的类型操作构成引用的引用，这种情况下适用引用坍缩（reference coolapsing）规则：右值引用的右值引用 坍缩成右值引用，所有其他组合均 坍缩成左值引用; * 当函数的返回值是左值引用时，函数调用表达式成为左值表达式：1234567typedef int&amp; lref;typedef int&amp;&amp; rref;int n;lref&amp; r1 = n; // r1 的类型是 int&amp;lref&amp;&amp; r2 = n; // r2 的类型是 int&amp;rref&amp; r3 = n; // r3 的类型是 int&amp;rref&amp;&amp; r4 = 1; // r4 的类型是 int&amp;&amp; 左值引用常规引用，一般表示对象的身份。右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 右值引用可用于为临时对象延长生存期（左值引用亦能延长临时对象生存期，但不能通过左值引用修改）成员初始化列表有些场合必须要用初始化列表： 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook 导入conda环境]]></title>
    <url>%2Funcategorized%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebook导入conda环境 不使用ipykernel，采用nb_condaconda install nb_conda 注意安装的时候不要激活环境 可以直接在jupyter里面安装包 可以在ipynb里面更改环境]]></content>
      <tags>
        <tag>conda</tag>
        <tag>jupyter</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
</search>
