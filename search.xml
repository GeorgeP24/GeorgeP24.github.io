<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++2.0]]></title>
    <url>%2Funcategorized%2FCpp11%2F</url>
    <content type="text"><![CDATA[auto autoä¸èƒ½ç”¨æ¥å£°æ˜å‡½æ•°çš„è¿”å›å€¼ã€‚ä½†æ˜¯å¦‚æœå‡½æ•°æœ‰ä¸€ä¸ªå°¾éšçš„è¿”å›ç±»å‹ï¼Œautoæ˜¯å¯ä»¥å£°æ˜è¿”å›å€¼ã€‚1234template&lt;class T1, class T2&gt;auto test(T1 t1,T2 t2) -&gt; **decltype**(t1 + t2)&#123; return t1+t2;&#125; std::array arrayå¯¹è±¡çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œä½¿ç”¨äº†é™æ€å­˜å‚¨åŒºï¼Œå³å­˜å‚¨åœ¨æ ˆä¸Šï¼Œæ•ˆç‡è·Ÿæ•°ç»„ç›¸åŒï¼Œä½†æ˜¯æ›´åŠ çš„å®‰å…¨ã€‚ nullptr nullptr-&gt;void* nullptræ˜¯std::nullptr_tã€‚å­˜åœ¨å’Œä»»ä½•æŒ‡é’ˆç±»å‹ä»¥åŠç±»æˆå‘˜æŒ‡é’ˆç±»å‹çš„ç©ºå€¼ï¼Œboolç±»å‹çš„éšå¼è½¬æ¢ã€‚ ä¸å­˜åœ¨æ•´å‹çš„éšå¼è½¬æ¢ã€‚12345678910f(int *p)&#123;&#125;f1(bool o)&#123;&#125;f2(std::share_ptr&lt;int&gt; p)&#123;&#125; int p1 = NULL;int p2 = nullptr;if(p1==p2);f(p2);f1(p2);f2(p2);int i = nullptr; //false åŸºäºèŒƒå›´çš„forå¾ªç¯12345678910111213for ( val declare : collection ) statementfor(int e : arr)&#123; e = e*e; std::cout&lt;&lt;e&lt;&lt;std::endl;&#125;template&lt;class InputIterator, class Function&gt; Function for_each( InputIterator _First, InputIterator _Last, Function _Func ); override final override:è¡¨ç¤ºå‡½æ•°åº”å½“é‡å†™åŸºç±»ä¸­çš„è™šå‡½æ•°ã€‚ final:è¡¨ç¤ºæ´¾ç”Ÿç±»ä¸åº”å½“é‡å†™è¿™ä¸ªè™šå‡½æ•°ã€‚12345678910111213141516171819class A&#123; public: virtual void func(int i)&#123; cout&lt;&lt;"A::f"&lt;&lt;endl; &#125;&#125;;class B : public A&#123; public: virtual void func(long l) final &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;;class C : public A&#123; public: virtual void func(int i) override &#123; cout&lt;&lt;"B::f"&lt;&lt;endl; &#125;&#125;; å¼ºç±»å‹æšä¸¾ ä¼ ç»Ÿenumä¼šå°†å¸¸é‡æš´éœ²åœ¨å¤–å±‚ä½œç”¨åŸŸã€‚å­˜åœ¨éšå¼æ•´å‹è½¬å‹ã€‚ å¼ºç±»å‹æšä¸¾ç”±å…³é”®å­—enum classæ ‡è¯†ï¼Œä¸å­˜åœ¨éšå¼è½¬æ•´å‹ã€‚12enum class a&#123;one,two,all&#125;;a ob = a::one; variadic templates å¯å˜å‚æ•°åˆ—è¡¨, ç±»å‹å’Œä¸ªæ•°ä»»æ„1234567891011template &lt;class T, class... Args&gt;void print(const T &amp;first, const Args &amp;... args)&#123; cout&lt;&lt;first&lt;&lt;endl; print(args...);&#125;void print()&#123;&#125;template&lt; class...T&gt;void print(const Args &amp;... args)&#123; /**/&#125; æ™ºèƒ½æŒ‡é’ˆ pointer-like classess#include&lt;memoray&gt; æ™ºèƒ½æŒ‡é’ˆæ„é€ å‡½æ•°æ˜¯explicit,æ‹’ç»éšå¼è½¬æ¢ã€‚ 123456shared_ptr&lt;double&gt;pd;double *p_reg = new double;pd = p_reg;//é”™è¯¯ï¼Œä¸å…è®¸éšå¼è½¬æ¢pd = shared_ptr&lt;double&gt;(p_reg);//æ­£ç¡®shared_ptr&lt;double&gt;pshared = p_reg;//é”™è¯¯ï¼Œä¸å…è®¸éšå¼è½¬æ¢shared_ptr&lt;double&gt;pshared(p_reg);//æ­£ç¡® ä¸èƒ½å°†smart point åº”ç”¨éå †å†…å­˜. aoto_ptrp(new T);auto_ptrp(new T);unique_ptrp(new T);##shared_ptrp(new T); 12345678910template &lt; class T&gt;class shared_ptr&#123; private: T *p; public: shared_ptr(T *pm):p(pm)&#123;&#125; T&amp; operator*() const&#123;return *p;&#125; T* operator-&gt;() const&#123;return p;&#125;&#125;;//-&gt;è¿ç®—ç¬¦ä½œç”¨ä¹‹åå¾—åˆ°çš„è¾“å‡ºç»§ç»­ç”¨-&gt;ä½œç”¨ã€‚ è¿­ä»£å™¨ pointer-like classes12345678910111213141516171819template&lt; class T&gt;struct __list_node&#123; void *prev; void *next; T data;&#125;;template&lt; class T,class Ref, class Ptr&gt;class __list_iterator&#123; typedef __list_iterator&lt;T,Ref,Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; link_type node; bool operator==(const self&amp;x)const&#123; return node == x.node; &#125; reference operator*() const &#123;return (*node).data;&#125; pointer operator-&gt;() const &#123;return &amp;(operator*());&#125;&#125; std::bind å°†å‡½æ•°ã€æˆå‘˜å‡½æ•°å’Œé—­åŒ…è½¬æˆfunctionå‡½æ•°å¯¹è±¡ å°†å¤šå…ƒ(n&gt;1)å‡½æ•°è½¬æˆä¸€å…ƒå‡½æ•°æˆ–è€…(n-1)å…ƒå‡½æ•°ã€‚ 123456789101112template&lt; class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );template&lt; class R, class F, class... Args &gt;/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args ); auto x1 = bind(f,10,20,10); auto x2 = bind(f,std::placeholders::_1,2,3); auto x3 = bind(f,std::placeholders::_1,23,std::placeholders::_2); auto x4 = bind&lt;double&gt;(f,std::placeholders::_1,std::placeholders::_2,5); cout&lt;&lt;x1()&lt;&lt;endl; cout&lt;&lt;x2(1)&lt;&lt;endl; cout&lt;&lt;x3(20,32)&lt;&lt;endl; cout&lt;&lt;x4(23,12)&lt;&lt;endl; æŸäº›æ— æ³•æ‹·è´çš„å‚æ•°ï¼Œåªèƒ½ä½¿ç”¨å¼•ç”¨ä¼ é€’ï¼Œéœ€è¦ä½¿ç”¨ref 1for_each(words.begin(),words.end,bind(print,ref(os),_1,' ')); bind æ— æ³•ç»‘å®šé‡è½½å‡½æ•°,å› ä¸ºé‡è½½å‡½æ•°å‚æ•°ä¸ªæ•°ä¸åŒã€‚ bind ç»‘å®šæˆå‘˜å‡½æ•°ï¼Œéœ€è¦ç±»çš„å®ä¾‹ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ã€‚ bind ç»‘å®šæˆå‘˜å‡½æ•°ï¼Œä¸éœ€è¦ç±»å®ä¾‹ã€‚ 123A a();auto m = bind(&amp;A::f(),a);m(); æœªå®Œå¾…ç»­]]></content>
      <tags>
        <tag>æœªå®Œå¾…ç»­</tag>
        <tag>c++</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å†…å­˜ç®¡ç†ä¾¯æ·]]></title>
    <url>%2Funcategorized%2Fmemory_control%2F</url>
    <content type="text"><![CDATA[å†…å­˜åˆ†é…æ–¹å¼ æ ˆ æ ˆå†…å­˜åˆ†é…è¿ç®—å†…ç½®äºå¤„ç†å™¨çš„æŒ‡ä»¤é›†ä¸­ï¼Œæ•ˆç‡å¾ˆé«˜ï¼Œä½†æ˜¯åˆ†é…çš„å†…å­˜å®¹é‡æœ‰é™ã€‚ å † æ‰‹åŠ¨deleteï¼Œç¨‹åºç»“æŸåï¼ŒOSè‡ªåŠ¨å›æ”¶ã€‚å †æ˜¯ä¸€å—è¿ç»­çš„å†…å­˜åŒºåŸŸã€‚è¿™å—å†…å­˜åŒºåŸŸçš„èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®ï¼Œå¹¶ä¸”è¿™å—è¿ç»­çš„å†…å­˜åŒºåŸŸå¯ä»¥è¢«ç¨‹åºå‘˜éšæ„ä½¿ç”¨ï¼Œå¹¶ä¸”è¿™å—åŒºåŸŸæ˜¯å¾ˆå¤§ã€‚ è‡ªç”±å˜é‡åŒº ç”±malloc å…¨å±€/é™æ€å­˜å‚¨åŒº å¸¸é‡å­˜å‚¨åŒº primitivesmalloc/freestd::allocatorother allocatorloki::allocator]]></content>
      <tags>
        <tag>c++</tag>
        <tag>å†…å­˜ç®¡ç†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŸºæœ¬æ•°æ®ç»“æ„æ•´ç†]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fdatastructure%2F</url>
    <content type="text"><![CDATA[é¡ºåºç»“æ„é¡ºåºæ ˆ12345678910111213template &lt;class T&gt;class sq_stack&#123;private: T val; int top; int size;public: sq_stack(); ~sq_stack(); T pop(); void insert(T val); int get_size(sq_stack s);&#125; é˜Ÿåˆ—1234567891011121314template&lt;class T&gt;class sq_queue&#123;private: T val; int front; int rear; int maxsize;public: sq_queue(); ~sq_queue(); int get_rear(sq_queue r); int get_front(sq_queue f); void insert(T val);&#125; é¡ºåºè¡¨123456template &lt;class T&gt;class sq_list&#123; vector&lt;T&gt; a; int length; int size;&#125; é“¾å¼ç»“æ„## 12345678910111213template &lt;class T&gt;class link_node&#123;private: T data; link_node *next;public: link_node(T d):data(d),next(nullptr)&#123;&#125; ~link_node();&#125;typedef struct Lnode&#123; elemtype data; struct Lnode *next;&#125;Lnode,*LinkList; å“ˆå¸Œè¡¨ å“ˆå¸Œå‡½æ•°ï¼šH(key): K -&gt; D , key âˆˆ K æ„é€ æ–¹æ³• ç›´æ¥å®šå€æ³• é™¤ç•™ä½™æ•°æ³• æ•°å­—åˆ†ææ³• æŠ˜å æ³• å¹³æ–¹å–ä¸­æ³• å†²çªè§£å†³æ–¹æ³•é“¾åœ°å€æ³•ï¼škeyç›¸åŒç”¨å•é“¾è¡¨é“¾æ¥å¼€æ”¾å®šå€æ³•ï¼š çº¿æ€§æ¢æµ‹æ³•ï¼šæ”¾åˆ°keyçš„ä¸‹ä¸€ä¸ªä½ç½®ï¼ŒHi = (H(key) + i) % m äºŒæ¬¡æ¢æµ‹æ³•ï¼šHi = (H(key) + i) % m éšæœºæ¢æµ‹æ³•ï¼šHi= (H(key) + ä¼ªéšæœºæ•°) % m 123456789101112typedef char KeyType;typedef struct&#123; KeyType key;&#125;RcdType;typedef struct&#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; ğŸŒ²äºŒå‰ğŸŒ²å­˜å‚¨ç»“æ„ é¡ºåºå­˜å‚¨ é“¾å¼å­˜å‚¨éå†æ–¹å¼ å…ˆåº ååº ä¸­åº å±‚æ¬¡å®ç°1234567891011121314template &lt;class T&gt;class binary_node&#123;private: binary_node *left; binary_node *right; T val;public: binary_node(int x):val(x),left(nullptr),right(nullptr)&#123;&#125; ~binary_node(); void in_order(binary_node *root); void pre_order(binary_node *root); void post_order(binary_node *root); void level_order(binary_node *root);&#125; ç±»å‹ æ»¡äºŒå‰ğŸŒ² å®Œå…¨äºŒå‰ğŸŒ²(å †) å¤§æ ¹å † å°æ ¹å † äºŒå‰æŸ¥æ‰¾ğŸŒ²(æ’åºğŸŒ²) å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºæˆ–ç­‰äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ã€‚ å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºæˆ–ç­‰äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ã€‚ å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æ’åºæ ‘ã€‚ æŸ¥æ‰¾çš„æœ€å¤§æ¬¡æ•°ç­‰äºæ•°çš„é«˜åº¦ã€‚ç¼ºç‚¹(å¤šæ¬¡æ’å…¥åå‘ä¸€è¾¹çš„æ•°æ®ï¼Œä¼šå¯¼è‡´ğŸŒ²ä¸¥é‡ä¸å¹³è¡¡) å¹³è¡¡äºŒå‰ğŸŒ²(AVL) æœ€å°å¤±è¡¡ğŸŒ²(å¹³è¡¡äºŒå‰æ ‘æ’å…¥æ–°çš„èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡çš„å­ğŸŒ²):è°ƒæ•´ç­–ç•¥ LL å·¦å­©å­å³æ—‹ RR å³å­©å­å·¦æ—‹ LR å·¦å­©å­å·¦æ—‹ï¼Œå†å³æ—‹ RL å³å­©å­çš„å·¦å­ğŸŒ²å…ˆå³æ—‹ï¼Œåœ¨å·¦æ—‹çº¢é»‘ğŸŒ²è§£å†³äº†äºŒå‰æŸ¥æ‰¾æ ‘çš„ä¸å¹³è¡¡é—®é¢˜ã€‚æœ€å¤§æŸ¥æ‰¾æ¬¡æ•°ä¸ä¼šè¶…è¿‡æœ€çŸ­è·¯å¾„çš„ä¸¤å€ã€‚ èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²ã€‚ æ ¹èŠ‚ç‚¹ä¸ºé»‘è‰²ã€‚ æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²çš„ç©ºèŠ‚ç‚¹ã€‚ æ¯ä¸ªçº¢è‰²èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²ã€‚(ä»æ¯ä¸ªå¶å­åˆ°æ ¹çš„æ‰€æœ‰è·¯å¾„ä¸Šä¸èƒ½æœ‰ä¸¤ä¸ªè¿ç»­çš„çº¢è‰²èŠ‚ç‚¹)ã€‚ ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­çš„æ‰€æœ‰è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹ã€‚è‡ªå¹³è¡¡ å˜è‰² æ—‹è½¬ å·¦æ—‹è½¬ é€†æ—¶é’ˆæ—‹è½¬çº¢é»‘æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å¾—çˆ¶èŠ‚ç‚¹è¢«è‡ªå·±çš„å³å­©å­å–ä»£ï¼Œè€Œè‡ªå·±æˆä¸ºè‡ªå·±çš„å·¦å­©å­ã€‚ å³æ—‹è½¬ é¡ºæ—¶é’ˆæ—‹è½¬çº¢é»‘æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å¾—çˆ¶èŠ‚ç‚¹è¢«è‡ªå·±çš„å·¦å­©å­å–ä»£ï¼Œè€Œè‡ªå·±æˆä¸ºè‡ªå·±çš„å³å­©å­ã€‚å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum tree_color(RED,BLACK);template &lt;class T&gt;class rb_node&#123;public: tree_color color; T key; rb_node *left; rb_node *right; rb_node *parent; rb_node(T val,rb_color c,rb_node l,rb_node r,rb_node p):key(val),color(c),left(l),right(r),parent(p)&#123;&#125;&#125;;template &lt;class T&gt;class rb_tree&#123; rb_tree(); ~rb_tree(); void pre_order(); void in_order(); void post_order(); rb_node&lt;T&gt;* re_search(T key); //é€’å½’æŸ¥æ‰¾ rb_node&lt;T&gt;* iter_serach(T key); //éé€’å½’ T minkey(); T maxkey(); rb_node&lt;T&gt;* successor(rb_node&lt;T&gt; *x); rb_node&lt;T&gt;* predecessor(rb_node&lt;T&gt; *x); void insert(T key); void remove(T key); void destory(); void print();private: void left_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x); void right_rotate(rb_node&lt;T&gt;* &amp;root,rb_node&lt;T&gt;* &amp;x);&#125;## BğŸŒ²* mé˜¶BğŸŒ² 1. æ¯ä¸ªç»“ç‚¹æœ€å¤šæœ‰m-1ä¸ªå…³é”®å­— 2. æ ¹ç»“ç‚¹æœ€å°‘å¯ä»¥åªæœ‰1ä¸ªå…³é”®å­— 3. æ¯ä¸ªç»“ç‚¹ä¸­çš„å…³é”®å­—éƒ½æŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—ï¼Œæ¯ä¸ªå…³é”®å­—çš„å·¦å­æ ‘ä¸­çš„æ‰€æœ‰å…³é”®å­—éƒ½å°äºå®ƒï¼Œè€Œå³å­æ ‘ä¸­çš„æ‰€æœ‰å…³é”®å­—éƒ½å¤§äºå®ƒ 4. æ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶å­ç»“ç‚¹é«˜åº¦ç›¸åŒ 5. éæ ¹ç»“ç‚¹è‡³å°‘æœ‰Math.ceil(m/2)-1ä¸ªå…³é”®å­—### å®ç°```c++template &lt;class T&gt;struct B_tree_node &#123; int n; T *key; bool is_leaf; struct B_tree_node *parent; struct B_tree_node **child;&#125;;template &lt;class T&gt;class B_tree&#123;private: B_tree_node&lt;T&gt;* root; int m;public: B_tree(int tVal = 2); ~B_tree(); B_tree_node&lt;T&gt;* search_tree(B_tree_node&lt;T&gt;* root, T k ,int &amp;index); B_tree_node&lt;T&gt;* getRoot(); void insert(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); void delete(B_tree_node&lt;T&gt;* root,B_tree_node&lt;T&gt;* node); T get_value(B_tree_node&lt;T&gt;* root,T value);&#125;; B+ Mé˜¶B+ğŸŒ² å†…ç»“ç‚¹å­˜æœ‰å…³é”®å­—å’ŒæŒ‡å‘å­©å­ç»“ç‚¹æŒ‡é’ˆã€‚å¤–ç»“ç‚¹å­˜æœ‰å…³é”®å­—å’Œæ•°æ®ã€‚ å¶å­ç»“ç‚¹è¿˜æœ‰å…³é”®å­—ï¼ŒæŒ‰ç…§å…³é”®å­—å¤§å°æ’åºï¼Œå¶å­ç»“ç‚¹ä¸­å­˜åœ¨æŒ‡å‘å…„å¼Ÿç»“ç‚¹çš„æŒ‡é’ˆã€‚ ä¸€é¢—B+ğŸŒ²å­˜åœ¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘æ ¹ç»“ç‚¹ï¼Œä¸€ä¸ªæŒ‡å‘å­˜æœ‰æœ€å°å…³é”®å­—çš„ç»“ç‚¹ã€‚ æœ‰næ£µå­æ ‘çš„ç»“ç‚¹ä¸­å«æœ‰nä¸ªå…³é”®å­—ï¼Œæ¯ä¸ªå…³é”®å­—ä¸ä¿å­˜æ•°æ®ï¼Œåªç”¨æ¥ç´¢å¼•ã€‚ 123456789101112template &lt;class T&gt;class bp_node&#123; public: bp_node(); virtual ~bp_node(); private: T data;&#125;;template &lt;class T&gt;class inter_node: public bp_node&#123; public:&#125; å…«å‰æ ‘å›¾æ’åºæŸ¥æ‰¾é€’å½’æŠ˜åŠæŸ¥æ‰¾å½’å¹¶æŸ¥æ‰¾å¿«é€Ÿæ’åºè¿­ä»£æŠ˜åŠæŸ¥æ‰¾å½’å¹¶æŸ¥æ‰¾]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>çº¢é»‘æ ‘</tag>
        <tag>Bæ ‘</tag>
        <tag>æœªå®Œå¾…ç»­</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++åŸºç¡€æ€»ç»“2]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_two%2F</url>
    <content type="text"><![CDATA[OOP å¤šæ€ C++å¤šæ€åˆ†ç±»åŠå…¶å®ç° é‡è½½å¤šæ€(Ad-hoc Polymorphism,ç¼–è¯‘æœŸ) å‡½æ•°é‡è½½ï¼Œè¿ç®—ç¬¦é‡è½½ å­ç±»å‹å¤šæ€(Subtype Polymorphism,è¿è¡ŒæœŸ) è™šå‡½æ•° å‚æ•°å¤šæ€æ€§(Parametric PolyMorphism) ç¼–è¯‘æœŸ ç±»æ¨¡æ¿ï¼Œå‡½æ•°æ¨¡æ¿ å¼ºåˆ¶å¤šæ€(Coerion PolyMorphism ç¼–è¯‘æœŸ,è¿è¡ŒæœŸ) ç±»å‹è½¬æ¢ é™æ€å¤šæ€ï¼ˆç¼–è¯‘æœŸé—´ï¼Œæ—©ç»‘å®šï¼‰ å‡½æ•°é‡è½½ åŠ¨æ€å¤šæ€ï¼ˆè¿è¡ŒæœŸé—´ï¼Œæ™šç»‘å®šï¼‰ è™šå‡½æ•° tips: æ™®é€šå‡½æ•°ä¸å¯æ˜¯virtual static ä¸å¯ä¸ºvirtual æ„é€ å‡½æ•°ä¸å¯ä¸ºvirtual,å› ä¸ºåœ¨è°ƒç”¨æ„é€ å‡½æ•°æ—¶ï¼Œè™šè¡¨æŒ‡é’ˆå¹¶æ²¡æœ‰åœ¨å¯¹è±¡çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå¿…é¡»è¦æ„é€ å‡½æ•°è°ƒç”¨å®Œæˆåæ‰ä¼šå½¢æˆè™šè¡¨æŒ‡é’ˆ virtual ~ä½œç”¨ * è§£å†³based point-&gt; derived object,ç”¨based point åˆ é™¤derived object.è™šå‡½æ•°æŒ‡é’ˆï¼Œè™šå‡½æ•°è¡¨è™šç»§æ‰¿è™šç»§æ‰¿ç”¨äºè§£å†³å¤šç»§æ‰¿æ¡ä»¶ä¸‹çš„è±å½¢ç»§æ‰¿é—®é¢˜æµª(è´¹å­˜å‚¨ç©ºé—´ã€å­˜åœ¨äºŒä¹‰æ€§) * åº•å±‚å®ç°åŸç†ä¸ç¼–è¯‘å™¨ç›¸å…³ï¼Œä¸€èˆ¬é€šè¿‡è™šåŸºç±»æŒ‡é’ˆå’Œè™šåŸºç±»è¡¨å®ç°ï¼Œæ¯ä¸ªè™šç»§æ‰¿çš„å­ç±»éƒ½æœ‰ä¸€ä¸ªè™šåŸºç±»æŒ‡é’ˆ(å ç”¨ä¸€ä¸ªæŒ‡é’ˆçš„å­˜å‚¨ç©ºé—´ï¼Œ4å­—èŠ‚ï¼‰å’Œè™šåŸºç±»è¡¨(ä¸å ç”¨ç±»å¯¹è±¡çš„å­˜å‚¨ç©ºé—´)(éœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œè™šåŸºç±»ä¾æ—§ä¼šåœ¨å­ç±»é‡Œé¢å­˜åœ¨æ‹·è´ï¼Œåªæ˜¯ä»…ä»…æœ€å¤šå­˜åœ¨ä¸€ä»½è€Œå·²ï¼Œå¹¶ä¸æ˜¯ä¸åœ¨å­ç±»é‡Œé¢äº†);å½“è™šç»§æ‰¿çš„å­ç±»è¢«å½“åšçˆ¶ç±»ç»§æ‰¿æ—¶ï¼Œè™šåŸºç±»æŒ‡é’ˆä¹Ÿä¼šè¢«ç»§æ‰¿ã€‚ * å®é™…ä¸Šï¼Œvbptr æŒ‡çš„æ˜¯è™šåŸºç±»è¡¨æŒ‡é’ˆï¼ˆvirtual base table pointerï¼‰ï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘äº†ä¸€ä¸ªè™šåŸºç±»è¡¨ï¼ˆvirtual tableï¼‰ï¼Œè™šè¡¨ä¸­è®°å½•äº†è™šåŸºç±»ä¸æœ¬ç±»çš„åç§»åœ°å€ï¼›é€šè¿‡åç§»åœ°å€ï¼Œè¿™æ ·å°±æ‰¾åˆ°äº†è™šåŸºç±»æˆå‘˜ï¼Œè€Œè™šç»§æ‰¿ä¹Ÿä¸ç”¨åƒæ™®é€šå¤šç»§æ‰¿é‚£æ ·ç»´æŒç€å…¬å…±åŸºç±»ï¼ˆè™šåŸºç±»ï¼‰çš„ä¸¤ä»½åŒæ ·çš„æ‹·è´ï¼ŒèŠ‚çœäº†å­˜å‚¨ç©ºé—´ã€‚è™šå‡½æ•°å’Œè™šç»§æ‰¿ éƒ½ä½¿ç”¨äº†è™šæŒ‡é’ˆ(å ç”¨ç±»çš„å­˜å‚¨ç©ºé—´)å’Œè™šè¡¨ï¼ˆä¸å ç±»å­˜å‚¨ç©ºé—´ï¼‰ è™šå‡½æ•°è¡¨å­˜å‚¨çš„æ˜¯è™šå‡½æ•°åœ°å€ï¼Œè™šåŸºç±»è¡¨å­˜å‚¨ç›¸å¯¹ç›´æ¥ç»§æ‰¿ç±»çš„ä½åç§»ã€‚ è™šåŸºç±»åœ¨å­ç±»ä¸­å­˜åœ¨ä¸€ä»½æ‹·è´ï¼Œè€Œè™šå‡½æ•°ä¸å ç”¨å­˜å‚¨ç©ºé—´ã€‚ tips: æ¨¡æ¿ç±»å¯ä»¥ä½¿ç”¨è™šå‡½æ•°ã€‚ ä½†ä»»ä½•ç±»çš„æˆå‘˜æ¨¡æ¿å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°ã€‚ èšåˆç±»ç”¨æˆ·å¯ä»¥ç›´æ¥è®¿é—®å…¶æˆå‘˜ï¼Œå¹¶ä¸”å…·æœ‰ç‰¹æ®Šçš„åˆå§‹åŒ–è¯­æ³•å½¢å¼ã€‚æ»¡è¶³å¦‚ä¸‹ç‰¹ç‚¹ï¼š æ‰€æœ‰æˆå‘˜éƒ½æ˜¯ public æ²¡æœ‰å®šä¹‰ä»»ä½•æ„é€ å‡½æ•° æ²¡æœ‰ç±»å†…åˆå§‹åŒ– æ²¡æœ‰åŸºç±»ï¼Œä¹Ÿæ²¡æœ‰ virtual å‡½æ•° å†…å­˜åˆ†é…ç®¡ç† malloc ç”³è¯·æŒ‡å®šå­—èŠ‚å†…å­˜ï¼Œåˆå§‹å€¼ä¸ç¡®å®šã€‚ char *str = (char*) malloc(100); calloc ä¸ºæŒ‡å®šé•¿åº¦çš„å¯¹è±¡ï¼Œåˆ†é…èƒ½å®¹çº³å…¶æŒ‡å®šä¸ªæ•°çš„å†…å­˜ã€‚ç”³è¯·åˆ°çš„å†…å­˜çš„æ¯ä¸€ä½ï¼ˆbitï¼‰éƒ½åˆå§‹åŒ–ä¸º 0ã€‚ realloc æ›´æ”¹ä»¥å‰åˆ†é…çš„å†…å­˜é•¿åº¦ï¼ˆå¢åŠ æˆ–å‡å°‘ï¼‰ã€‚å½“å¢åŠ é•¿åº¦æ—¶ï¼Œå¯èƒ½éœ€å°†ä»¥å‰åˆ†é…åŒºçš„å†…å®¹ç§»åˆ°å¦ä¸€ä¸ªè¶³å¤Ÿå¤§çš„åŒºåŸŸï¼Œè€Œæ–°å¢åŒºåŸŸå†…çš„åˆå§‹å€¼åˆ™ä¸ç¡®å®šã€‚ alloca åœ¨æ ˆä¸Šç”³è¯·å†…å­˜ã€‚ç¨‹åºåœ¨å‡ºæ ˆçš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œalloca ä¸å…·å¯ç§»æ¤æ€§, è€Œä¸”åœ¨æ²¡æœ‰ä¼ ç»Ÿå †æ ˆçš„æœºå™¨ä¸Šå¾ˆéš¾å®ç°ã€‚alloca ä¸å®œä½¿ç”¨åœ¨å¿…é¡»å¹¿æ³›ç§»æ¤çš„ç¨‹åºä¸­ã€‚C99 ä¸­æ”¯æŒå˜é•¿æ•°ç»„ (VLA)ï¼Œå¯ä»¥ç”¨æ¥æ›¿ä»£ allocaã€‚ new/new[]å…ˆåº•å±‚è°ƒç”¨mallocï¼Œç„¶åè°ƒç”¨æ„é€ å‡½æ•°ã€‚ delete/delete[]å…ˆè°ƒç”¨ææ„å‡½æ•°ï¼Œç„¶åfreeï¼ŒæŒ‡é’ˆç½®ä¸ºç©ºã€‚ newèƒ½è‡ªåŠ¨è®¡ç®—æ‰€éœ€å­—èŠ‚æ•°ï¼Œæ— éœ€åƒmallocä¸€æ ·æ‰‹åŠ¨æ“ä½œã€‚ pacement newå…è®¸ä¼ é€’é¢å¤–çš„åœ°å€å‚æ•°ï¼Œé¢„å…ˆåœ¨æŒ‡å®šçš„å†…å­˜åŒºåŸŸåˆ›å»ºå¯¹è±¡ã€‚ 123456new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list&#125;//place_address ä¸º point//initializerså¯èƒ½ä¸ºç©ºçš„åˆå§‹åŒ–åˆ—è¡¨ tips: delete this åˆæ³•å‰æ ä¹‹åä¸å†è°ƒç”¨thisæŒ‡é’ˆ(ä»»ä½•è°ƒç”¨) thiså¯¹è±¡ç”±newè€Œä¸æ˜¯å…¶ä»–ä»»ä½•æ–¹å¼åˆ†é…çš„ã€‚ è¯¥æˆå‘˜å‡½æ•°æ˜¯thiså¯¹è±¡æœ€åè°ƒç”¨çš„çš„æˆå‘˜å‡½æ•°ã€‚ å‰©ä¸‹çš„æˆå‘˜å‡½æ•°ï¼ˆdelete thisä¹‹åçš„)ä¸æ¥è§¦åˆ°thiså¯¹è±¡,åŒ…æ‹¬è°ƒç”¨ä»»ä½•å…¶ä»–æˆå‘˜å‡½æ•°æˆ–è®¿é—®ä»»ä½•æ•°æ®æˆå‘˜ã€‚ åªåœ¨å †ä¸Šç”Ÿæˆå¯¹è±¡çš„ç±»æ–¹æ³•ï¼šå°†è™šæ„å‡½æ•°ç§æœ‰ã€‚ (C++ æ˜¯é™æ€ç»‘å®šè¯­è¨€ï¼Œç¼–è¯‘å™¨ç®¡ç†æ ˆä¸Šå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œç¼–è¯‘å™¨åœ¨ä¸ºç±»å¯¹è±¡åˆ†é…æ ˆç©ºé—´æ—¶ï¼Œä¼šå…ˆæ£€æŸ¥ç±»çš„ææ„å‡½æ•°çš„è®¿é—®æ€§ã€‚è‹¥ææ„å‡½æ•°ä¸å¯è®¿é—®ï¼Œåˆ™ä¸èƒ½åœ¨æ ˆä¸Šåˆ›å»ºå¯¹è±¡ã€‚) åªåœ¨æ ˆä¸Šç”Ÿæˆå¯¹è±¡çš„ç±»æ–¹æ³•ï¼šå°†newå’Œdeleteæ“ä½œç¬¦é‡è½½ä¸ºç§æœ‰ã€‚ ï¼šC++ æ˜¯é™æ€ç»‘å®šè¯­è¨€ï¼Œç¼–è¯‘å™¨ç®¡ç†æ ˆä¸Šå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œç¼–è¯‘å™¨åœ¨ä¸ºç±»å¯¹è±¡åˆ†é…æ ˆç©ºé—´æ—¶ï¼Œä¼šå…ˆæ£€æŸ¥ç±»çš„ææ„å‡½æ•°çš„è®¿é—®æ€§ã€‚è‹¥ææ„å‡½æ•°ä¸å¯è®¿é—®ï¼Œåˆ™ä¸èƒ½åœ¨æ ˆä¸Šåˆ›å»ºå¯¹è±¡ã€‚]]></content>
      <categories>
        <category>è¯­è¨€</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>é¢è¯•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++åŸºç¡€æ€»ç»“1]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Finterview_one%2F</url>
    <content type="text"><![CDATA[const(ä¸å¯å˜)ä½œç”¨1. ä¿®é¥°å¸¸é‡ 2. ä¿®é¥°æŒ‡é’ˆ æŒ‡é’ˆå¸¸é‡å’Œå¸¸é‡æŒ‡é’ˆ 3. å¸¸é‡å¼•ç”¨ é¿å…æ‹·è´ï¼Œé¿å…å¯¹å€¼çš„ä¿®æ”¹ï¼Œä¸èƒ½ä½¿ç”¨éconstå¼•ç”¨æŒ‡å‘constå¯¹è±¡ã€‚ 4. ä¿®é¥°æˆå‘˜å‡½æ•° å‡½æ•°å†…éƒ¨ä¸èƒ½ä¿®æ”¹æˆå‘˜å‡½æ•°ä½¿ç”¨123456789101112131415161718192021const int a1;int get() const;const char* p1 = a2;//å¸¸é‡æŒ‡é’ˆï¼ŒæŒ‡å‘å¸¸é‡çš„æŒ‡é’ˆï¼Œä¿æŠ¤æŒ‡å‘çš„åœ°å€ç©ºé—´æ•°æ®ä¸å¯å˜ã€‚æŒ‡é’ˆå¯å˜ï¼Œå¯ä»¥ä¿®æ”¹constæŒ‡é’ˆæ‰€æŒ‡å‘çš„å€¼çš„ï¼Œä½†æ˜¯ä¸èƒ½é€šè¿‡constå¯¹è±¡æŒ‡é’ˆæ¥è¿›è¡Œï¼Œè‡ªä»¥ä¸ºæŒ‡å‘constçš„æŒ‡é’ˆã€‚char* p = a2;*p = a3;char* const p2 = a3;//æŒ‡é’ˆå¸¸é‡ï¼Œ ä¿æŠ¤æŒ‡é’ˆï¼ŒæŒ‡é’ˆè‡ªèº«çš„åœ°å€ç©ºé—´ä¸å¯å˜ï¼Œæ•°æ®å¯å˜ã€‚//ä¸èƒ½æŠŠå¸¸é‡çš„åœ°å€èµ‹ç»™æŒ‡é’ˆå˜é‡void get(const int val);void get(const int *val);void get(int *const val);//file1.cppint cout;const int cout2;extern const int cout3;//file2.cppextern int cout; //åœ¨å…¨å±€ä½œç”¨åŸŸé‡Œå®šä¹‰éconstå˜é‡æ—¶ï¼Œå®ƒåœ¨æ•´ä¸ªç¨‹åºä¸­éƒ½å¯ä»¥è®¿é—®cout++;cout2; //erroré™¤éç‰¹åˆ«è¯´æ˜ï¼Œåœ¨å…¨å±€ä½œç”¨åŸŸå£°æ˜çš„constå˜é‡æ˜¯å®šä¹‰è¯¥å¯¹è±¡çš„æ–‡ä»¶çš„å±€éƒ¨å˜é‡ï¼Œåªå­˜åœ¨äºé‚£ä¸ªæ–‡ä»¶ï¼Œä¸èƒ½è¢«å…¶ä»–æ–‡ä»¶è®¿é—®ã€‚extern const int cout3;cout3++; static()ä½œç”¨1. ä¿®é¥°æ™®é€šå˜é‡ï¼Œä¿®æ”¹å˜é‡çš„å­˜å‚¨åŒºåŸŸå’Œç”Ÿå‘½å‘¨æœŸï¼Œä½¿å˜é‡å­˜å‚¨åœ¨é™æ€åŒºï¼Œåœ¨ main å‡½æ•°è¿è¡Œå‰åˆ†é…ç©ºé—´ï¼Œå¦‚æœæœ‰åˆå§‹å€¼å°±ç”¨åˆå§‹å€¼åˆå§‹åŒ–ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹å€¼ç³»ç»Ÿç”¨é»˜è®¤å€¼åˆå§‹åŒ–ã€‚ 2. ä¿®é¥°æ™®é€šå‡½æ•°ï¼Œè¯¥å‡½æ•°ä»…åœ¨å®šä¹‰è¯¥å‡½æ•°çš„æ–‡ä»¶å†…æ‰èƒ½ä½¿ç”¨ã€‚ 3. ä¿®é¥°æˆå‘˜å˜é‡ï¼Œä¿®é¥°æˆå‘˜å˜é‡ä½¿æ‰€æœ‰çš„å¯¹è±¡åªä¿å­˜ä¸€ä¸ªè¯¥å˜é‡ï¼Œè€Œä¸”ä¸éœ€è¦ç”Ÿæˆå¯¹è±¡å°±å¯ä»¥è®¿é—®è¯¥æˆå‘˜ã€‚ 4. ä¿®é¥°æˆå‘˜å‡½æ•°ï¼Œä¿®é¥°æˆå‘˜å‡½æ•°ä½¿å¾—ä¸éœ€è¦ç”Ÿæˆå¯¹è±¡å°±å¯ä»¥è®¿é—®è¯¥å‡½æ•°ï¼Œä½¿ç”¨ç±»åä½œç”¨åŸŸç¬¦å·è®¿é—®ï¼Œä½†æ˜¯åœ¨ static å‡½æ•°å†…ä¸èƒ½è®¿é—®éé™æ€æˆå‘˜ã€‚thisæŒ‡é’ˆ1. æŒ‡å‘éé™æ€æˆå‘˜çš„ç‰¹æ®ŠæŒ‡é’ˆã€‚ 2. å½“å¯¹ä¸€ä¸ªå¯¹è±¡è°ƒç”¨æˆå‘˜å‡½æ•°æ—¶ï¼Œç¼–è¯‘ç¨‹åºå…ˆå°†å¯¹è±¡çš„åœ°å€èµ‹ç»™ this æŒ‡é’ˆï¼Œç„¶åè°ƒç”¨æˆå‘˜å‡½æ•°ï¼Œæ¯æ¬¡æˆå‘˜å‡½æ•°å­˜å–æ•°æ®æˆå‘˜æ—¶ï¼Œéƒ½éšå¼ä½¿ç”¨ this æŒ‡é’ˆã€‚ 3. this æŒ‡é’ˆè¢«éšå«åœ°å£°æ˜ä¸º: ClassName *const thisï¼Œè¿™æ„å‘³ç€ä¸èƒ½ç»™ this æŒ‡é’ˆèµ‹å€¼ã€‚åœ¨ ClassName ç±»çš„ const æˆå‘˜å‡½æ•°ä¸­ï¼Œthis æŒ‡é’ˆçš„ç±»å‹ä¸ºï¼šconst ClassName* constï¼Œè¿™è¯´æ˜ä¸èƒ½å¯¹ this æŒ‡é’ˆæ‰€æŒ‡å‘çš„è¿™ç§å¯¹è±¡æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼ˆå³ä¸èƒ½å¯¹è¿™ç§å¯¹è±¡çš„æ•°æ®æˆå‘˜è¿›è¡Œèµ‹å€¼æ“ä½œï¼‰ã€‚ 4. this åªæ˜¯ä¸€ä¸ªå³å€¼ï¼Œä¸èƒ½ä½¿ç”¨&amp;this 5. åœ¨ä»¥ä¸‹åœºæ™¯ä¸­ï¼Œç»å¸¸éœ€è¦æ˜¾å¼å¼•ç”¨ this æŒ‡é’ˆï¼š 1. ä¸ºå®ç°å¯¹è±¡çš„é“¾å¼å¼•ç”¨ã€‚ 2. ä¸ºé¿å…å¯¹åŒä¸€å¯¹è±¡è¿›è¡Œèµ‹å€¼æ“ä½œã€‚ 3. åœ¨å®ç°ä¸€äº›æ•°æ®ç»“æ„æ—¶ï¼Œå¦‚ listã€‚inlineç‰¹å¾1. ç›¸å½“äºç›´æ¥æ‰§è¡Œå‡½æ•°ä½“ã€‚ 2. ç›¸å½“äºå®æ“ä½œï¼Œä½†æ˜¯å¤šäº†ç±»å‹æ£€æŸ¥ã€‚ 3. ç¼–è¯‘å™¨ä¸€èˆ¬ä¸å†…æ•›åŒ…å«å¾ªç¯ï¼Œé€’å½’ï¼Œswitchç­‰å¤æ‚æ“ä½œçš„inlineå‡½æ•°ã€‚ 4. åœ¨ç±»å£°æ˜ä¸­å®šä¹‰çš„å‡½æ•°ï¼Œé™¤äº†è™šå‡½æ•°çš„å…¶ä»–å‡½æ•°ä¼šè‡ªåŠ¨éšå¼åœ°å½“æˆinlineå‡½æ•°ã€‚ä½¿ç”¨12345// ç±»å¤–å®šä¹‰éœ€è¦æ˜¾ç¤ºinlineclass A&#123; void b();&#125;inline void A::b()&#123;&#125;; ç¼–è¯‘å™¨å¯¹inlineå‡½æ•°çš„å¤„ç†è¿‡ç¨‹1. å‡½æ•°ä½“å¤åˆ¶åˆ°è°ƒç”¨ç‚¹ã€‚ 2. ä¸ºå±€éƒ¨å˜é‡åˆ†é…å†…å­˜ç©ºé—´ã€‚ 3. å°†inlineå‡½æ•°ä¸­çš„è¾“å…¥å‚æ•°å’Œè¿”å›å€¼æ˜ å°„åˆ°è°ƒç”¨æ–¹æ³•çš„å±€éƒ¨å˜é‡ç©ºé—´ã€‚ 4. å¦‚æœ inline å‡½æ•°æœ‰å¤šä¸ªè¿”å›ç‚¹ï¼Œå°†å…¶è½¬å˜ä¸º inline å‡½æ•°ä»£ç å—æœ«å°¾çš„åˆ†æ”¯ï¼ˆä½¿ç”¨ gotoï¼‰ã€‚ä¼˜åŠ£ä¼˜ç‚¹1. å†…è”å‡½æ•°åŒå®å‡½æ•°ä¸€æ ·å°†åœ¨è¢«è°ƒç”¨å¤„è¿›è¡Œä»£ç å±•å¼€ï¼Œçœå»äº†å‚æ•°å‹æ ˆã€æ ˆå¸§å¼€è¾Ÿä¸å›æ”¶ï¼Œç»“æœè¿”å›ç­‰ï¼Œä»è€Œæé«˜ç¨‹åºè¿è¡Œé€Ÿåº¦ã€‚ 2. å†…è”å‡½æ•°ç›¸æ¯”å®å‡½æ•°æ¥è¯´ï¼Œåœ¨ä»£ç å±•å¼€æ—¶ï¼Œä¼šåšå®‰å…¨æ£€æŸ¥æˆ–è‡ªåŠ¨ç±»å‹è½¬æ¢ï¼ˆåŒæ™®é€šå‡½æ•°ï¼‰ï¼Œè€Œå®å®šä¹‰åˆ™ä¸ä¼šã€‚ 3. åœ¨ç±»ä¸­å£°æ˜åŒæ—¶å®šä¹‰çš„æˆå‘˜å‡½æ•°ï¼Œè‡ªåŠ¨è½¬åŒ–ä¸ºå†…è”å‡½æ•°ï¼Œå› æ­¤å†…è”å‡½æ•°å¯ä»¥è®¿é—®ç±»çš„æˆå‘˜å˜é‡ï¼Œå®å®šä¹‰åˆ™ä¸èƒ½ã€‚ 4. å†…è”å‡½æ•°åœ¨è¿è¡Œæ—¶å¯è°ƒè¯•ï¼Œè€Œå®å®šä¹‰ä¸å¯ä»¥ã€‚ç¼ºç‚¹1. ä»£ç è†¨èƒ€ï¼Œçœå»äº†è°ƒç”¨å‡½æ•°çš„å¼€é”€ã€‚å…³é”®åœ¨äºå‡½æ•°ä½“å†…æ‰§è¡Œæ—¶é—´å’Œè°ƒç”¨å‡½æ•°å¼€é”€çš„å¹³è¡¡ã€‚ 2. inlineå‡½æ•°æ— æ³•éšç€å‡½æ•°åº“å‡çº§è€Œå‡çº§ï¼Œinlineå‡½æ•°æ”¹å˜éœ€è¦é‡æ–°ç¼–è¯‘ï¼Œæ— æ³•ç›´æ¥é“¾æ¥ã€‚ 3. æ˜¯å¦å†…è”ï¼Œç¨‹åºå‘˜ä¸å¯æ§ã€‚å†…è”å‡½æ•°åªæ˜¯å¯¹ç¼–è¯‘å™¨çš„å»ºè®®ï¼Œæ˜¯å¦å¯¹å‡½æ•°å†…è”ï¼Œå†³å®šæƒåœ¨äºç¼–è¯‘å™¨ã€‚tips: virtualå¯ä»¥inlineï¼Œä½†æ˜¯å½“virtualè¡¨ç¤ºå¤šæ€æ€§æ—¶ï¼Œä¸èƒ½å†…è”ã€‚ inlineæ˜¯ç¼–è¯‘å™¨å»ºè®®ç¼–è¯‘å™¨å†…è”ï¼Œåœ¨ç¨‹åºè¿è¡Œä¹‹å‰ï¼Œä½†æ˜¯å¤šæ€æ€§çš„è¡¨ç°åœ¨ç¨‹åºè¿è¡Œä¸­ã€‚ å½“ç¼–è¯‘å™¨æ˜ç¡®çŸ¥é“è°ƒç”¨å¯¹è±¡æ˜¯å“ªä¸€ä¸ªç±»æ—¶ï¼Œå…·æœ‰å®é™…å¯¹è±¡ï¼Œè€Œä¸æ˜¯å¯¹è±¡æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œå¯ä»¥ä½¿ç”¨ inline virtual volatile1volatile int a = 1; 1. volatile å…³é”®å­—æ˜¯ä¸€ç§ç±»å‹ä¿®é¥°ç¬¦ï¼Œç”¨å®ƒå£°æ˜çš„ç±»å‹å˜é‡è¡¨ç¤ºå¯ä»¥è¢«æŸäº›ç¼–è¯‘å™¨æœªçŸ¥çš„å› ç´ ï¼ˆæ“ä½œç³»ç»Ÿã€ç¡¬ä»¶ã€å…¶å®ƒçº¿ç¨‹ç­‰ï¼‰æ›´æ”¹ã€‚æ‰€ä»¥ä½¿ç”¨ volatile å‘Šè¯‰ç¼–è¯‘å™¨ä¸åº”å¯¹è¿™æ ·çš„å¯¹è±¡è¿›è¡Œä¼˜åŒ–ã€‚ 2. volatile å…³é”®å­—å£°æ˜çš„å˜é‡ï¼Œæ¯æ¬¡è®¿é—®æ—¶éƒ½å¿…é¡»ä»å†…å­˜ä¸­å–å‡ºå€¼ï¼ˆæ²¡æœ‰è¢« volatile ä¿®é¥°çš„å˜é‡ï¼Œå¯èƒ½ç”±äºç¼–è¯‘å™¨çš„ä¼˜åŒ–ï¼Œä» CPU å¯„å­˜å™¨ä¸­å–å€¼ï¼‰ 3. const å¯ä»¥æ˜¯ volatile ï¼ˆå¦‚åªè¯»çš„çŠ¶æ€å¯„å­˜å™¨ï¼‰ 4. æŒ‡é’ˆå¯ä»¥æ˜¯ volatile12345678## assert()æ–­è¨€ï¼Œæ˜¯å®ï¼Œè€Œéå‡½æ•°ã€‚assert å®çš„åŸå‹å®šä¹‰åœ¨ &lt;assert.h&gt;ï¼ˆCï¼‰ã€&lt;cassert&gt;ï¼ˆC++ï¼‰ä¸­ï¼Œå…¶ä½œç”¨æ˜¯å¦‚æœå®ƒçš„æ¡ä»¶è¿”å›é”™è¯¯ï¼Œåˆ™ç»ˆæ­¢ç¨‹åºæ‰§è¡Œã€‚å¯ä»¥é€šè¿‡å®šä¹‰ NDEBUG æ¥å…³é—­ assertï¼Œä½†æ˜¯éœ€è¦åœ¨æºä»£ç çš„å¼€å¤´ï¼Œinclude &lt;assert.h&gt; ä¹‹å‰ã€‚### ä½¿ç”¨```c++# define NDEBUG# cinlude &lt;cassert&gt;assert(p!=NULL); pragma pack(n)å¼ºåˆ¶è®¾å®šstruct,union,classæˆå‘˜å˜é‡ä»¥n å­—èŠ‚å¯¹é½æ–¹å¼ã€‚ 12#pragma pack(push)#pragma pack(8) ä½åŸŸ1Bit mode:2; ç±»å¯ä»¥å°†å…¶ï¼ˆéé™æ€ï¼‰æ•°æ®æˆå‘˜å®šä¹‰ä¸ºä½åŸŸï¼ˆbit-fieldï¼‰ï¼Œåœ¨ä¸€ä¸ªä½åŸŸä¸­å«æœ‰ä¸€å®šæ•°é‡çš„äºŒè¿›åˆ¶ä½ã€‚ ä½åŸŸå†…å­˜å¸ƒå±€å’Œæœºå™¨æœ‰å…³ ç±»å‹å¿…é¡»æ˜¯æ•´å‹æˆ–è€…æšä¸¾ï¼Œsigned intæ ¹æ®å…·ä½“å®ç°è€Œå®šã€‚ å–åœ°å€å’ŒæŒ‡é’ˆä¸èƒ½ä½œç”¨äºä½åŸŸã€‚ extern â€œCâ€æŒ‰ç…§Cè¯­è¨€æ–¹å¼ç¼–è¯‘å’Œé“¾æ¥ã€‚extern â€œCâ€ çš„ä½œç”¨æ˜¯è®© C++ ç¼–è¯‘å™¨å°† extern â€œCâ€ å£°æ˜çš„ä»£ç å½“ä½œ C è¯­è¨€ä»£ç å¤„ç†ï¼Œå¯ä»¥é¿å… C++ å› ç¬¦å·ä¿®é¥°å¯¼è‡´ä»£ç ä¸èƒ½å’ŒCè¯­è¨€åº“ä¸­çš„ç¬¦å·è¿›è¡Œé“¾æ¥çš„é—®é¢˜ã€‚ 1234567#ifdef _cpextern "C"&#123;#endif void *memeset(void *,int ,size_t);#ifdef _cp&#125;#endif structc12345typedef struct a&#123;&#125;s;// ç­‰ä»·äºstruct a&#123;&#125;;typedef struct a s;// ä½†ä¸¤ä¸ªæ ‡è¯†ç¬¦åç§°ç©ºé—´ä¸ç›¸åŒã€‚ cppç¼–è¯‘å™¨å®šä½ç¬¦å·çš„è§„åˆ™æ”¹å˜ï¼Œé¦–å…ˆæœç´¢å…¨å±€æ ‡è¯†ç¬¦è¡¨ï¼Œå¦‚æœæ²¡æœ‰å°†ä¼šæœç´¢ç±»æ ‡è¯†ç¬¦è¡¨ã€‚ æ²¡æœ‰åŒåç±» Aï¼Œå¯çœç•¥struct 12struct A&#123;&#125;;void m(A m); å¦‚æœæœ‰åŒåç±» Aï¼Œåˆ™A ä»£è¡¨ç±»Aï¼Œstruct A ä»£è¡¨ç»“æ„ä½“Aã€‚ classå’Œstruct æœ¬è´¨åŒºåˆ«æ˜¯é»˜è®¤çš„è®¿é—®æƒé™ï¼Œstructé»˜è®¤public,classé»˜è®¤privateã€‚ unionè”åˆï¼ˆunionï¼‰æ˜¯ä¸€ç§èŠ‚çœç©ºé—´çš„ç‰¹æ®Šçš„ç±»ï¼Œä¸€ä¸ª union å¯ä»¥æœ‰å¤šä¸ªæ•°æ®æˆå‘˜ï¼Œä½†æ˜¯åœ¨ä»»æ„æ—¶åˆ»åªæœ‰ä¸€ä¸ªæ•°æ®æˆå‘˜å¯ä»¥æœ‰å€¼ã€‚å½“æŸä¸ªæˆå‘˜è¢«èµ‹å€¼åå…¶ä»–æˆå‘˜å˜ä¸ºæœªå®šä¹‰çŠ¶æ€ã€‚è”åˆæœ‰å¦‚ä¸‹ç‰¹ç‚¹ï¼š * é»˜è®¤æƒé™public * å¯ä»¥å«æœ‰ææ„å‡½æ•°ï¼Œæ„é€ å‡½æ•° * ä¸èƒ½å«æœ‰å¼•ç”¨ç±»å‹çš„æˆå‘˜ * ä¸èƒ½ä½œä¸ºderived classï¼Œä¸èƒ½ä½œä¸ºbase class * ä¸èƒ½å«æœ‰virtual * åŒ¿åunionåœ¨å®šä¹‰æ‰€åœ¨çš„scopeå¯ç›´æ¥è®¿é—®union member * åŒ¿åunionä¸èƒ½åŒ…å«protectedå’Œprivate member * å…¨å±€åŒ¿åè”åˆå¿…é¡»æ˜¯staticã€‚explicit ä¿®é¥°æ„é€ å‡½æ•°ï¼Œé˜²æ­¢éšå¼è½¬æ¢å’Œå¤åˆ¶åˆå§‹åŒ–ã€‚ ä¿®é¥°è½¬æ¢å‡½æ•°ï¼Œé˜²æ­¢éšå¼è½¬æ¢ï¼ŒæŒ‰è¯­å¢ƒè½¬æ¢é™¤å¤–ã€‚ æŒ‰è¯­å¢ƒè½¬æ¢ ifã€whileã€for çš„æ§åˆ¶è¡¨è¾¾å¼ï¼› å†…å»ºé€»è¾‘è¿ç®—ç¬¦ !ã€&amp;&amp; å’Œ || çš„æ“ä½œæ•°ï¼› æ¡ä»¶è¿ç®—ç¬¦ ?: çš„é¦–ä¸ªæ“ä½œæ•°ï¼› static_assert å£°æ˜ä¸­çš„è°“è¯ï¼› noexcept è¯´æ˜ç¬¦ä¸­çš„è¡¨è¾¾å¼ï¼›12345678910111213141516171819202122232425262728293031class A&#123; A(int a)&#123;&#125; operator bool() const &#123;return false;&#125;&#125;;class B&#123; B(int b)&#123;&#125; explicit operator bool() const&#123;return false;&#125;&#125;;void getA(A a)&#123;&#125;void getB(B b)&#123;&#125;int main()&#123; A a1(1);//ç›´æ¥åˆå§‹åŒ– A a2 = 1;//å¤åˆ¶åˆå§‹åŒ– A a3&#123;1&#125;;//ç›´æ¥åˆ—è¡¨åˆå§‹åŒ– A a4 = &#123;1&#125;;//å¤åˆ¶åˆ—è¡¨åˆå§‹åŒ– A a5 = (A)1;//å…è®¸static_cast æ˜¾ç¤ºè½¬å‹ getA(1);//å…è®¸intåˆ°Açš„éšå¼è½¬æ¢ if (a1);//ä½¿ç”¨è½¬æ¢å‡½æ•°A::operator bool() çš„ä»Aåˆ°boolçš„éšå¼è½¬æ¢ bool a6(a1);//ä½¿ç”¨è½¬æ¢å‡½æ•° A::operator bool()çš„ä»Aåˆ°boolçš„éšå¼è½¬æ¢ bool a7 = a1;//ä½¿ç”¨è½¬æ¢å‡½æ•°A::operator bool()çš„ä»Aåˆ°boolçš„éšå¼è½¬æ¢ bool a8 = static_cast&lt;bool&gt;(a1);//static_cast è¿›è¡Œç›´æ¥åˆå§‹åŒ– B b1(1);//ok B b2 = 1;//false, explitctä¿®é¥°çš„æ„é€ å‡½æ•°ä¸å¯å¤åˆ¶åˆå§‹åŒ–ï¼Œä¸å¯å¤åˆ¶åˆ—è¡¨åˆå§‹åŒ– getB(b1);// è¢«explicitä¿®é¥°çš„æ„é€ å‡½æ•°çš„å¯¹è±¡ä¸å…è®¸ä½ intåˆ°Béšå¼è½¬æ¢ if(b1); bool b6(b1); //è¢«explicit ä¿®é¥°çš„è½¬æ¢å‡½æ•°çš„å¯¹è±¡å¯ä»¥æŒ‰è¯­å¢ƒè½¬æ¢ã€‚ bool b7 = b1; falseï¼Œè¢«explicitä¿®é¥°çš„æ„é€ å‡½æ•°çš„å¯¹è±¡ä¸å…è®¸Båˆ°boolçš„è½¬å‹ã€‚ bool b8 = static_cast&lt;bool&gt;(b1); return 0;&#125; å¼•ç”¨1) å·¦å€¼å¼•ç”¨å£°æ˜ç¬¦ï¼šå£°æ˜ S&amp; D; å°† D å£°æ˜ä¸ºåˆ° å£°æ˜è¯´æ˜ç¬¦åºåˆ— æ‰€ç¡®å®šçš„ç±»å‹ S çš„å·¦å€¼å¼•ç”¨ã€‚ 2) å³å€¼å¼•ç”¨å£°æ˜ç¬¦ï¼šå£°æ˜ S&amp;&amp; D; å°† D å£°æ˜ä¸ºåˆ° å£°æ˜è¯´æ˜ç¬¦åºåˆ— æ‰€ç¡®å®šçš„ç±»å‹ S çš„å³å€¼å¼•ç”¨ã€‚ * ä¸å­˜åœ¨ void çš„å¼•ç”¨ï¼Œä¹Ÿä¸å­˜åœ¨å¼•ç”¨çš„å¼•ç”¨,å¼•ç”¨çš„æ•°ç»„,æŒ‡å‘å¼•ç”¨çš„æŒ‡é’ˆ. * å¼•ç”¨åç¼©ï¼šå®¹è®¸é€šè¿‡æ¨¡æ¿æˆ– typedef ä¸­çš„ç±»å‹æ“ä½œæ„æˆå¼•ç”¨çš„å¼•ç”¨ï¼Œè¿™ç§æƒ…å†µä¸‹é€‚ç”¨å¼•ç”¨åç¼©ï¼ˆreference coolapsingï¼‰è§„åˆ™ï¼šå³å€¼å¼•ç”¨çš„å³å€¼å¼•ç”¨ åç¼©æˆå³å€¼å¼•ç”¨ï¼Œæ‰€æœ‰å…¶ä»–ç»„åˆå‡ åç¼©æˆå·¦å€¼å¼•ç”¨; * å½“å‡½æ•°çš„è¿”å›å€¼æ˜¯å·¦å€¼å¼•ç”¨æ—¶ï¼Œå‡½æ•°è°ƒç”¨è¡¨è¾¾å¼æˆä¸ºå·¦å€¼è¡¨è¾¾å¼ï¼š1234567typedef int&amp; lref;typedef int&amp;&amp; rref;int n;lref&amp; r1 = n; // r1 çš„ç±»å‹æ˜¯ int&amp;lref&amp;&amp; r2 = n; // r2 çš„ç±»å‹æ˜¯ int&amp;rref&amp; r3 = n; // r3 çš„ç±»å‹æ˜¯ int&amp;rref&amp;&amp; r4 = 1; // r4 çš„ç±»å‹æ˜¯ int&amp;&amp; å·¦å€¼å¼•ç”¨å¸¸è§„å¼•ç”¨ï¼Œä¸€èˆ¬è¡¨ç¤ºå¯¹è±¡çš„èº«ä»½ã€‚å³å€¼å¼•ç”¨å³å€¼å¼•ç”¨å°±æ˜¯å¿…é¡»ç»‘å®šåˆ°å³å€¼ï¼ˆä¸€ä¸ªä¸´æ—¶å¯¹è±¡ã€å°†è¦é”€æ¯çš„å¯¹è±¡ï¼‰çš„å¼•ç”¨ï¼Œä¸€èˆ¬è¡¨ç¤ºå¯¹è±¡çš„å€¼ã€‚ å³å€¼å¼•ç”¨å¯å®ç°è½¬ç§»è¯­ä¹‰ï¼ˆMove Sementicsï¼‰å’Œç²¾ç¡®ä¼ é€’ï¼ˆPerfect Forwardingï¼‰ï¼Œå®ƒçš„ä¸»è¦ç›®çš„æœ‰ä¸¤ä¸ªæ–¹é¢ï¼š æ¶ˆé™¤ä¸¤ä¸ªå¯¹è±¡äº¤äº’æ—¶ä¸å¿…è¦çš„å¯¹è±¡æ‹·è´ï¼ŒèŠ‚çœè¿ç®—å­˜å‚¨èµ„æºï¼Œæé«˜æ•ˆç‡ã€‚ èƒ½å¤Ÿæ›´ç®€æ´æ˜ç¡®åœ°å®šä¹‰æ³›å‹å‡½æ•°ã€‚ å³å€¼å¼•ç”¨å¯ç”¨äºä¸ºä¸´æ—¶å¯¹è±¡å»¶é•¿ç”Ÿå­˜æœŸï¼ˆå·¦å€¼å¼•ç”¨äº¦èƒ½å»¶é•¿ä¸´æ—¶å¯¹è±¡ç”Ÿå­˜æœŸï¼Œä½†ä¸èƒ½é€šè¿‡å·¦å€¼å¼•ç”¨ä¿®æ”¹ï¼‰æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨æœ‰äº›åœºåˆå¿…é¡»è¦ç”¨åˆå§‹åŒ–åˆ—è¡¨ï¼š 1. å¸¸é‡æˆå‘˜ï¼Œå› ä¸ºå¸¸é‡åªèƒ½åˆå§‹åŒ–ä¸èƒ½èµ‹å€¼ï¼Œæ‰€ä»¥å¿…é¡»æ”¾åœ¨åˆå§‹åŒ–åˆ—è¡¨é‡Œé¢ 2. å¼•ç”¨ç±»å‹ï¼Œå¼•ç”¨å¿…é¡»åœ¨å®šä¹‰çš„æ—¶å€™åˆå§‹åŒ–ï¼Œå¹¶ä¸”ä¸èƒ½é‡æ–°èµ‹å€¼ï¼Œæ‰€ä»¥ä¹Ÿè¦å†™åœ¨åˆå§‹åŒ–åˆ—è¡¨é‡Œé¢ 3. æ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„ç±»ç±»å‹ï¼Œå› ä¸ºä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨å¯ä»¥ä¸å¿…è°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°æ¥åˆå§‹åŒ–]]></content>
      <categories>
        <category>è¯­è¨€</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>é¢è¯•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++å¤šçº¿ç¨‹]]></title>
    <url>%2F%E8%AF%AD%E8%A8%80%2Fthread%2F</url>
    <content type="text"><![CDATA[å¤šè¿›ç¨‹å¹¶å‘å°†åº”ç”¨ç¨‹åºåˆ†ä¸ºå¤šä¸ªç‹¬ç«‹çš„è¿›ç¨‹ï¼Œå®ƒä»¬åœ¨åŒä¸€æ—¶åˆ»è¿è¡Œï¼Œå°±åƒåŒæ—¶è¿›è¡Œç½‘é¡µæµè§ˆå’Œæ–‡å­—å¤„ç†ä¸€æ ·ã€‚ç‹¬ç«‹çš„è¿›ç¨‹å¯ä»¥é€šè¿‡è¿›ç¨‹é—´å¸¸è§„çš„é€šä¿¡æ¸ é“ä¼ é€’è®¯æ¯ã€‚ + ç¼ºç‚¹ å› ä¸ºOSçš„ä¿æŠ¤æªæ–½ï¼Œè¿›ç¨‹ä¹‹é—´çš„é€šä¿¡é€šå¸¸å¤æ‚æˆ–è€…æ…¢ã€‚ è¿è¡Œå¤šä¸ªè¿›ç¨‹éœ€è¦æ—¶é—´å¯åŠ¨è¿›ç¨‹ï¼Œæ“ä½œç³»ç»Ÿéœ€è¦å†…éƒ¨èµ„æºæ¥ç®¡ç†è¿›ç¨‹ã€‚ + ä¼˜ç‚¹ OS åœ¨è¿›ç¨‹é—´æä¾›é™„åŠ çš„ä¿æŠ¤æ“ä½œå’Œé«˜çº§åˆ«çš„é€šä¿¡æœºåˆ¶ï¼Œä½¿å¾—æ›´å®¹æ˜“ç¼–å†™å®‰å…¨çš„å¹¶å‘ä»£ç ã€‚ å¯ä»¥ä½¿ç”¨è¿œç¨‹è¿æ¥çš„æ–¹å¼ï¼Œåœ¨ä¸åŒçš„æœºå™¨ä¸Šè¿è¡Œç‹¬ç«‹çš„è¿›ç¨‹ã€‚å¤šçº¿ç¨‹å¹¶å‘å¹¶å‘çš„å¦ä¸€ä¸ªé€”å¾„æ˜¯åœ¨å•ä¸ªè¿›ç¨‹ä¸­è¿è¡Œå¤šä¸ªçº¿ç¨‹ã€‚çº¿ç¨‹ç±»ä¼¼äºè½»é‡çº§çš„è¿›ç¨‹ã€‚ + ç¼ºç‚¹ ç¼ºå°‘çº¿ç¨‹é—´çš„æ•°æ®ä¿æŠ¤ï¼Œå¦‚æœæ•°æ®è¦è¢«å¤šä¸ªçº¿ç¨‹è®¿é—®ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿æ¯ä¸ªçº¿ç¨‹æ‰€è®¿é—®çš„çš„æ•°æ®æ˜¯ä¸€è‡´çš„ï¼Œå› æ­¤éœ€è¦å¯¹çº¿ç¨‹é€šä¿¡åšå¤§é‡çš„å·¥ä½œã€‚ + ä¼˜ç‚¹ å…±äº«åœ°å€ç©ºé—´ï¼Œç¼ºå°‘æ•°æ®ä¿æŠ¤ï¼Œæ‰€ä»¥å·¥ä½œé‡å°ï¼Œå¤šçº¿ç¨‹å¼€é”€è¿œå°äºå¤šè¿›ç¨‹ã€‚C++ 11 std::thread+ C++ 11 å¼•å…¥äº†&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;å’Œ&lt;future&gt;ã€‚+ å£°æ˜äº† std::atomicå’Œ std::atomic_flag + ç”Ÿå‘½äº†ä¸€å¥—Cé£æ ¼çš„åŸå­ç±»å‹åŠå…¼å®¹Cçš„æ“ä½œå‡½æ•°ã€‚+ å£°æ˜äº† std::thread,std::this_thread+ å£°æ˜äº†ç›¸å…³mutexç±»ã€‚ + std::mutex,std::lock_guard,std::unique_lock.+ ç›¸å…³condition_variable ç±»ï¼Œ std::condition_variableå’Œstd::condition_variable_any+ std::promise,std::package_task.std çº¿ç¨‹ç±»+ std::thread ç±»çš„æ„é€ å‡½æ•°ä½¿ç”¨å¯å˜å‚æ•°æ¨¡æ¿ã€‚ 1template&lt;typename _Callable, typename... _Args&gt; 1. å‡½æ•°æŒ‡é’ˆ 2. é‡è½½è¿ç®—ç¬¦çš„ç±»å¯¹è±¡,ä»¿å‡½æ•° 3. lambdaè¡¨è¾¾å¼ 4. std::functionå‡½æ•°æŒ‡é’ˆ1234567891011void func1()&#123;&#125;void func2(int i)&#123;&#125;void func3(int i,std::string m)&#123;&#125;std::thread t1(func1);std::thread t2(func2,1);std::thread t3(func3,1,"abc");t1.join();t2.join();t3.join(); ä»¿å‡½æ•°123456789101112class Fctor &#123;public: // å…·æœ‰ä¸€ä¸ªå‚æ•° void operator() () &#123; &#125;&#125;;Fctor f;std::thread t1(f); std::thread t2(Fctor()); // falsestd::thread t3((Fctor())); // okstd::thread t4&#123;Fctor()&#125;; // ok ä¸€ä¸ªä»¿å‡½æ•°ç±»ç”Ÿæˆçš„å¯¹è±¡ï¼Œä½¿ç”¨èµ·æ¥å°±åƒä¸€ä¸ªå‡½æ•°ä¸€æ ·. t2é”™è¯¯ï¼Œç¼–è¯‘å™¨æŠŠFctor()è§£é‡Šä¸ºå‡½æ•°å£°æ˜ï¼Œå¹¶éæ˜¯ä¸´æ—¶å¯¹è±¡ã€‚ åœ¨å‚æ•°æ·»åŠ å°æ‹¬å·ï¼Œè¿›è¡Œè°ƒç”¨ã€‚ ä½¿ç”¨{}è¿›è¡Œæ„é€ ã€‚ lambda å‡½æ•°123456std::thread t1([]()&#123; std::cout&lt;&lt;"lambda"&lt;&lt;std::endl;&#125;);//æ— å‚std::thread t2([](std::int m)&#123; std::cout&lt;&lt;"lambda"&lt;&lt;m&lt;&lt;std::endl;&#125;,1);//æœ‰å‚ std::fucntion1234567891011121314151617181920212223class A&#123;public: void func1()&#123; &#125; void func2(int i)&#123; &#125; void func3(int i, int j)&#123; &#125;&#125;;A a;std::function&lt;void(void)&gt; f1 = std::bind(&amp;A::func1, &amp;a);std::function&lt;void(void)&gt; f2 = std::bind(&amp;A::func2, &amp;a, 1);std::function&lt;void(int)&gt; f3 = std::bind(&amp;A::func2, &amp;a, std::placeholders::_1);std::function&lt;void(int)&gt; f4 = std::bind(&amp;A::func3, &amp;a, 1, std::placeholders::_1);std::function&lt;void(int, int)&gt; f5 = std::bind(&amp;A::func3, &amp;a, std::placeholders::_1, std::placeholders::_2);std::thread t1(f1);std::thread t2(f2);std::thread t3(f3, 1);std::thread t4(f4, 1);std::thread t5(f5, 1, 2); æ„é€ å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¯è°ƒç”¨å¯¹è±¡ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¼ é€’çš„æ˜¯ä¸€ä¸ªå‰¯æœ¬ã€‚å½“ä½¿ç”¨æ„é€ å‡½æ•°åˆ›å»ºå¯¹è±¡çš„æ—¶å€™ï¼Œæ˜¯å°†å‚æ•°å…ˆèµ‹å€¼ç»™è¿™äº›å˜é‡ï¼Œæ‰€ä»¥è¿™äº›å˜é‡åªæ˜¯ä¸ªå‰¯æœ¬ï¼Œç„¶ååœ¨çº¿ç¨‹å¯åŠ¨å¹¶è°ƒç”¨çº¿ç¨‹å…¥å£å‡½æ•°æ—¶ï¼Œä¼ é€’çš„å‚æ•°åªæ˜¯è¿™äº›å‰¯æœ¬ã€‚ çº¿ç¨‹å¯¹è±¡åªèƒ½ç§»åŠ¨ä¸å¯å¤åˆ¶å°†çº¿ç¨‹çš„æ‰€æœ‰æƒåœ¨std::threadå®ä¾‹é—´è¿›è¡Œè½¬ç§»ã€‚1234void f1();void f2();std::thread t1(f1);std::thread t2 = std::move(t1); ä½¿ç”¨ref()å’Œmove()ä¼ é€’å¼•ç”¨,thread t(f,ref(m));]]></content>
      <categories>
        <category>è¯­è¨€</category>
      </categories>
      <tags>
        <tag>æœªå®Œå¾…ç»­</tag>
        <tag>çº¿ç¨‹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¼‚å¸¸ç±»]]></title>
    <url>%2Funcategorized%2Fexception%2F</url>
    <content type="text"><![CDATA[ä¸­å®šä¹‰äº†ä¸€ç³»åˆ—æ ‡å‡†çš„å¼‚å¸¸ã€‚ std::exceptionstd::bad_alloc è¯¥å¼‚å¸¸å¯ä»¥é€šè¿‡ new æŠ›å‡ºã€‚std::bad_cast è¯¥å¼‚å¸¸é€šè¿‡dynamic_castæŠ›å‡ºã€‚std::bad_exception std::bad_typeid è¯¥å¼‚å¸¸å¯ä»¥é€šè¿‡ typeid æŠ›å‡ºã€‚std::logic_error ç†è®ºä¸Šå¯ä»¥é€šè¿‡è¯»å–ä»£ç æ¥æ£€æµ‹åˆ°çš„å¼‚å¸¸ã€‚std::domain_error å½“ä½¿ç”¨äº†ä¸€ä¸ªæ— æ•ˆçš„æ•°å­¦åŸŸæ—¶ï¼Œä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ã€‚std::invalid_argument å½“ä½¿ç”¨äº†æ— æ•ˆçš„å‚æ•°æ—¶ï¼Œä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ã€‚std::length_error å½“åˆ›å»ºäº†å¤ªé•¿çš„ std::string æ—¶ï¼Œä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ã€‚std::out_of_range è¯¥å¼‚å¸¸å¯ä»¥é€šè¿‡æ–¹æ³•æŠ›å‡ºï¼Œä¾‹å¦‚ std::vector å’Œ std::bitset&lt;&gt;::operatorã€‚std::runtime_error ç†è®ºä¸Šä¸å¯ä»¥é€šè¿‡è¯»å–ä»£ç æ¥æ£€æµ‹åˆ°çš„å¼‚å¸¸ã€‚std::overflow_error å½“å‘ç”Ÿæ•°å­¦ä¸Šæº¢æ—¶ï¼Œä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ã€‚std::range_error å½“å°è¯•å­˜å‚¨è¶…å‡ºèŒƒå›´çš„å€¼æ—¶ï¼Œä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ã€‚std::underflow_error å½“å‘ç”Ÿæ•°å­¦ä¸‹æº¢æ—¶ï¼Œä¼šæŠ›å‡ºè¯¥å¼‚å¸¸ã€‚]]></content>
      <tags>
        <tag>æœªå®Œå¾…ç»­</tag>
        <tag>å¼‚å¸¸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memo]]></title>
    <url>%2Funcategorized%2Fmemo%2F</url>
    <content type="text"><![CDATA[æ–¹æ³•ä¸€ï¼šæš´åŠ›æ³•123456789int climb(int i,int n)&#123;if(i&gt;n) return 0;if(i ==n) return 1;return climb(i+1,n)+climb(i+2,n);&#125;int climbs(int n)&#123; return climb(0,n);&#125; æ—¶é—´å¤æ‚åº¦ï¼šO(2n)O(2^n)O(2n)ã€‚æ ‘å½¢é€’å½’çš„å¤§å°ä¸º 2n2^n2n . ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚é€’å½’æ ‘çš„æ·±åº¦å¯ä»¥è¾¾åˆ° nn æ–¹æ³• 2ï¼šè®°å¿†åŒ–é€’å½’12345678910111213class Solution&#123; public: climbs(int n)&#123; vector&lt;int&gt; memo; return climbs(0,n,memo); &#125; int climb_memo(int i,int n,vector&lt;int&gt; memo)&#123; if(i&gt;n) return 0; if(i ==n) return 1; if(memo[i]&gt;0) return memo[i]; return climb_memo(i+1,n,memo)+climb_memo(i+2,n,memo); &#125;&#125; æ—¶é—´å¤æ‚åº¦ï¼šO(n) ã€‚æ ‘å½¢é€’å½’çš„å¤§å°å¯ä»¥è¾¾åˆ° n. ç©ºé—´å¤æ‚åº¦ï¼šO(n) ã€‚é€’å½’æ ‘çš„æ·±åº¦å¯ä»¥è¾¾åˆ° n. æ–¹æ³• 3ï¼šåŠ¨æ€è§„åˆ’12345678910111213class Solution&#123; public: climbs(int n)&#123; if(n==1) return 1; &#125; vector&lt;int&gt; dp; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++)&#123; dp[i] = dp[i-1] + dp[i-2] &#125; return dp[n];&#125; æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå•å¾ªç¯åˆ° n ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(n), dp æ•°ç»„ç”¨äº† n çš„ç©ºé—´]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook å¯¼å…¥condaç¯å¢ƒ]]></title>
    <url>%2Funcategorized%2Fjupyter%2F</url>
    <content type="text"><![CDATA[jupyter notebookå¯¼å…¥condaç¯å¢ƒ ä¸ä½¿ç”¨ipykernelï¼Œé‡‡ç”¨nb_condaconda install nb_conda æ³¨æ„å®‰è£…çš„æ—¶å€™ä¸è¦æ¿€æ´»ç¯å¢ƒ å¯ä»¥ç›´æ¥åœ¨jupyteré‡Œé¢å®‰è£…åŒ… å¯ä»¥åœ¨ipynbé‡Œé¢æ›´æ”¹ç¯å¢ƒ]]></content>
      <tags>
        <tag>conda</tag>
        <tag>jupyter</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
</search>
